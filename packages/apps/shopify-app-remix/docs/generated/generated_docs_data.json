[
  {
    "name": "AppProvider",
    "description": "Sets up the Polaris `AppProvider` and injects the App Bridge script.\n\nThis component extends the [`AppProvider`](https://polaris.shopify.com/components/utilities/app-provider) component from Polaris, and accepts all of its props except for `linkComponent`, which is overridden to use the Remix `Link` component.\n\n\n\n\n\n\n\n\n\n",
    "category": "Entrypoints",
    "type": "component",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "AppProviderProps",
        "description": "Props for the `AppProvider` component.",
        "type": "AppProviderProps",
        "typeDefinitions": {
          "AppProviderProps": {
            "filePath": "src/react/components/AppProvider/AppProvider.tsx",
            "name": "AppProviderProps",
            "description": "",
            "members": [
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "apiKey",
                "value": "string",
                "description": "The API key for your Shopify app. This is the `Client ID` from the Partner Dashboard.\n\nWhen using the Shopify CLI, this is the `SHOPIFY_API_KEY` environment variable. If you're using the environment variable, then you need to pass it from the loader to the component."
              },
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "isEmbeddedApp",
                "value": "boolean",
                "description": "Whether the app is loaded inside the Shopify Admin. Default is `true`.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TranslationDictionary | TranslationDictionary[]",
                "description": "The internationalization (i18n) configuration for your Polaris provider.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "__APP_BRIDGE_URL",
                "value": "string",
                "description": "Used internally by Shopify. You don't need to set this.",
                "isOptional": true,
                "isPrivate": true
              },
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "theme",
                "value": "ThemeName",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "features",
                "value": "FeaturesConfig",
                "description": "For toggling features",
                "isOptional": true
              },
              {
                "filePath": "src/react/components/AppProvider/AppProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "React.ReactNode",
                "description": "Inner content of the application",
                "isOptional": true
              }
            ],
            "value": "export interface AppProviderProps\n  extends Omit<PolarisAppProviderProps, 'linkComponent' | 'i18n'> {\n  /**\n   * The API key for your Shopify app. This is the `Client ID` from the Partner Dashboard.\n   *\n   * When using the Shopify CLI, this is the `SHOPIFY_API_KEY` environment variable. If you're using the environment\n   * variable, then you need to pass it from the loader to the component.\n   */\n  apiKey: string;\n  /**\n   * Whether the app is loaded inside the Shopify Admin. Default is `true`.\n   *\n   * {@link https://shopify.dev/docs/apps/admin/embedded-app-home}\n   */\n  isEmbeddedApp?: boolean;\n  /**\n   * The internationalization (i18n) configuration for your Polaris provider.\n   *\n   * {@link https://polaris.shopify.com/components/utilities/app-provider}\n   */\n  i18n?: PolarisAppProviderProps['i18n'];\n  /**\n   * Used internally by Shopify. You don't need to set this.\n   * @private\n   */\n  __APP_BRIDGE_URL?: string;\n}"
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "AppProviderGeneratedType"
    ],
    "related": [
      {
        "name": "App bridge",
        "subtitle": "Learn more about App Bridge.",
        "url": "/docs/api/app-bridge-library",
        "type": "shopify"
      },
      {
        "name": "Polaris",
        "subtitle": "Learn more about Polaris.",
        "url": "/docs/apps/tools/polaris",
        "type": "shopify"
      }
    ],
    "examples": {
      "description": "",
      "examples": [
        {
          "description": "Wrap your app in the `AppProvider` component and pass in your API key.",
          "codeblock": {
            "title": "Set up AppProvider",
            "tabs": [
              {
                "title": "/app/routes/**\\/*.ts",
                "code": "import {authenticate} from '~/shopify.server';\nimport {AppProvider} from '@shopify/shopify-app-remix/react';\n\nexport async function loader({ request }) {\n  await authenticate.admin(request);\n\n  return json({ apiKey: process.env.SHOPIFY_API_KEY });\n}\n\nexport default function App() {\n  const { apiKey } = useLoaderData();\n\n  return (\n    &lt;AppProvider isEmbeddedApp apiKey={apiKey}&gt;\n      &lt;Outlet /&gt;\n    &lt;/AppProvider&gt;\n  );\n}",
                "language": "typescript"
              }
            ]
          }
        },
        {
          "description": "Pass in a different locale for Polaris to translate its components.",
          "codeblock": {
            "title": "Localize Polaris components",
            "tabs": [
              {
                "title": "/app/routes/**\\/*.ts",
                "code": "import {authenticate} from '~/shopify.server';\nimport {AppProvider} from '@shopify/shopify-app-remix/react';\n\nexport async function loader({ request }) {\n  await authenticate.admin(request);\n\n  return json({\n    apiKey: process.env.SHOPIFY_API_KEY,\n    polarisTranslations: require(\"@shopify/polaris/locales/fr.json\"),\n  });\n}\n\nexport default function App() {\n  const { apiKey, polarisTranslations } = useLoaderData();\n\n  return (\n    &lt;AppProvider apiKey={apiKey} i18n={polarisTranslations}&gt;\n      &lt;Outlet /&gt;\n    &lt;/AppProvider&gt;\n  );\n}",
                "language": "typescript"
              }
            ]
          }
        }
      ]
    }
  },
  {
    "name": "AppProxyForm",
    "description": "Sets up a Remix `<Form>` component that works when rendered behind an app proxy.\n\nSupports any properties accepted by the `<Form>` component.",
    "category": "App proxy components",
    "type": "component",
    "isVisualComponent": false,
    "definitions": [],
    "jsDocTypeExamples": [
      "AppProxyFormGeneratedType"
    ],
    "related": [
      {
        "name": "authenticate.public.appProxy",
        "subtitle": "Authenticating app proxy requests.",
        "url": "/docs/api/shopify-app-remix/authenticate/public/app-proxy",
        "type": "remix"
      },
      {
        "name": "AppProxyProvider",
        "subtitle": "Enable JavaScript in pages loaded through app proxies.",
        "url": "/docs/api/shopify-app-remix/app-proxy-components/appproxyprovider",
        "type": "remix"
      }
    ],
    "defaultExample": {
      "description": "Use an `AppProxyForm` within an `AppProxy` to create a form.",
      "codeblock": {
        "title": "Render a form element in a proxied route",
        "tabs": [
          {
            "title": "/app/routes/**\\/*.ts",
            "code": "import {\n  AppProxyProvider,\n  AppProxyForm,\n} from \"@shopify/shopify-app-remix/react\";\nimport { authenticate } from \"~/shopify.server\";\n\nexport async function loader({ request }) {\n  await authenticate.public.appProxy(request);\n\n  return json({ appUrl: process.env.SHOPIFY_APP_URL });\n}\n\nexport async function action({ request }) {\n  await authenticate.public.appProxy(request);\n\n  const formData = await request.formData();\n  const field = formData.get(\"field\")?.toString();\n\n  // Perform actions\n  if (field) {\n    console.log(\"Field:\", field);\n  }\n\n  // Return JSON to the client\n  return json({ message: \"Success!\" });\n}\n\nexport default function App() {\n  const { appUrl } = useLoaderData();\n  const data = useActionData();\n\n  return (\n    &lt;AppProxyProvider appUrl={appUrl}&gt;\n      &lt;AppProxyForm action=\"/\"&gt;\n        &lt;input type=\"text\" name=\"field\" defaultValue={data?.field} /&gt;\n\n        &lt;input type=\"submit\" name=\"Submit\" /&gt;\n      &lt;/AppProxyForm&gt;\n    &lt;/AppProxyProvider&gt;\n  );\n}",
            "language": "typescript"
          }
        ]
      }
    }
  },
  {
    "name": "AppProxyLink",
    "description": "Sets up an `<a />` HTML element that works when rendered behind an app proxy.\n\nSupports any properties accepted by the `<a />` HTML element.",
    "category": "App proxy components",
    "type": "component",
    "isVisualComponent": false,
    "definitions": [],
    "jsDocTypeExamples": [
      "AppProxyLinkGeneratedType"
    ],
    "related": [
      {
        "name": "authenticate.public.appProxy",
        "subtitle": "Authenticating app proxy requests.",
        "url": "/docs/api/shopify-app-remix/authenticate/public/app-proxy",
        "type": "remix"
      },
      {
        "name": "AppProxyProvider",
        "subtitle": "Enable JavaScript in pages loaded through app proxies.",
        "url": "/docs/api/shopify-app-remix/app-proxy-components/appproxyprovider",
        "type": "remix"
      }
    ],
    "defaultExample": {
      "description": "Use an `AppProxyLink` within an `AppProxyProvider` to link to a different proxied route.",
      "codeblock": {
        "title": "Link to a different route",
        "tabs": [
          {
            "title": "/app/routes/**\\/*.ts",
            "code": "import {authenticate} from '~/shopify.server';\nimport {AppProxyProvider, AppProxyLink} from '@shopify/shopify-app-remix/react';\n\nexport async function loader({ request }) {\n  await authenticate.public.appProxy(request);\n\n  return json({ appUrl: process.env.SHOPIFY_APP_URL });\n}\n\nexport default function App() {\n  const { appUrl } = useLoaderData();\n\n  return (\n    &lt;AppProxyProvider appUrl={appUrl}&gt;\n      &lt;AppProxyLink href=\"/other-proxy-route\"&gt;Link to another route&lt;/AppProxyLink&gt;\n    &lt;/AppProxyProvider&gt;\n  );\n}",
            "language": "typescript"
          }
        ]
      }
    }
  },
  {
    "name": "AppProxyProvider",
    "description": "Sets up a page to render behind a Shopify app proxy, enabling JavaScript and CSS to be loaded from the app.\n\nAlso provides components that enable using other components such as links and forms within proxies.\n\n> Caution: Because Remix doesn't support URL rewriting, any route using this component should <b>match the pathname of the proxy URL exactly</b>, and <b>end in a trailing slash</b> (e.g., `https://<shop>/apps/proxy/`).",
    "category": "Entrypoints",
    "type": "component",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "AppProxyProviderProps",
        "description": "Props for the `AppProxyProvider` component.",
        "type": "AppProxyProviderProps",
        "typeDefinitions": {
          "AppProxyProviderProps": {
            "filePath": "src/react/components/AppProxyProvider/AppProxyProvider.tsx",
            "name": "AppProxyProviderProps",
            "description": "",
            "members": [
              {
                "filePath": "src/react/components/AppProxyProvider/AppProxyProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "appUrl",
                "value": "string",
                "description": "The URL where the app is hosted. You can set this from the `SHOPIFY_APP_URL` environment variable."
              },
              {
                "filePath": "src/react/components/AppProxyProvider/AppProxyProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "React.ReactNode",
                "description": "The children to render.",
                "isOptional": true
              }
            ],
            "value": "export interface AppProxyProviderProps {\n  /**\n   * The URL where the app is hosted. You can set this from the `SHOPIFY_APP_URL` environment variable.\n   */\n  appUrl: string;\n\n  /**\n   * The children to render.\n   */\n  children?: React.ReactNode;\n}"
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "AppProxyProviderGeneratedType"
    ],
    "related": [
      {
        "name": "authenticate.public.appProxy",
        "subtitle": "Authenticate app proxy requests.",
        "url": "/docs/api/shopify-app-remix/authenticate/public/app-proxy",
        "type": "remix"
      },
      {
        "name": "AppProxyForm",
        "subtitle": "Render form elements in proxies.",
        "url": "/docs/api/shopify-app-remix/app-proxy-components/appproxy-form",
        "type": "remix"
      },
      {
        "name": "AppProxyLink",
        "subtitle": "Render link elements in proxies.",
        "url": "/docs/api/shopify-app-remix/app-proxy-components/appproxy-link",
        "type": "remix"
      }
    ],
    "defaultExample": {
      "description": "Wrap your route component in the `AppProxyProvider` component and pass in your app URL.",
      "codeblock": {
        "title": "Wrap a route with an AppProxyProvider component",
        "tabs": [
          {
            "title": "/app/routes/**\\/*.ts",
            "code": "import {authenticate} from '~/shopify.server';\nimport {AppProxyProvider} from '@shopify/shopify-app-remix/react';\n\nexport async function loader({ request }) {\n  await authenticate.public.appProxy(request);\n\n  return json({ appUrl: process.env.SHOPIFY_APP_URL });\n}\n\nexport default function App() {\n  const { appUrl } = useLoaderData();\n\n  return (\n    &lt;AppProxyProvider appUrl={appUrl}&gt;\n      Page content\n    &lt;/AppProxyProvider&gt;\n  );\n}",
            "language": "typescript"
          }
        ]
      }
    }
  },
  {
    "name": "Admin",
    "description": "Contains functions for authenticating and interacting with the Admin API.\n\nThis function can handle requests for apps embedded in the Admin, Admin extensions, or non-embedded apps.",
    "category": "Authenticate",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "authenticate.admin",
        "description": "Authenticates requests coming from the Shopify admin.\n\nThe shape of the returned object changes depending on the `isEmbeddedApp` config.",
        "type": "AuthenticateAdmin",
        "typeDefinitions": {
          "AuthenticateAdmin": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "AuthenticateAdmin",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/admin/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/admin/types.ts",
              "description": "",
              "name": "Promise<AdminContext<Config, Resources>>",
              "value": "Promise<AdminContext<Config, Resources>>"
            },
            "value": "export type AuthenticateAdmin<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> = (request: Request) => Promise<AdminContext<Config, Resources>>;"
          },
          "AdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AdminContext",
            "value": "Config['isEmbeddedApp'] extends false\n  ? NonEmbeddedAdminContext<Config, Resources>\n  : EmbeddedAdminContext<Config, Resources>",
            "description": ""
          },
          "NonEmbeddedAdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "NonEmbeddedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the user who made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using offline sessions",
                    "description": "Get your app's shop-specific data using an offline session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Using online sessions",
                    "description": "Get your app's user-specific data using an online session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request."
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingContext<Config>",
                "description": "Billing methods for this store, based on the plans defined in the `billing` config option.\n\n\n\n\n"
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a admin request",
                    "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface NonEmbeddedAdminContext<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends AdminContextInternal<Config, Resources> {}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          },
          "BillingContext": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "BillingContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "require",
                "value": "(options: RequireBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Requesting billing right away",
                    "description": "Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirect to a plan selection page",
                    "description": "When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n    isTest: true,\n    onFailure: () => redirect('/select-plan'),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Requesting billing with line items",
                    "description": "Call `billing.request` with the `v3_lineItemBilling` future flag enabled",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      lineItems: [\n       {\n         amount: 5,\n         currencyCode: 'USD',\n         interval: BillingInterval.Every30Days,\n        },\n        {\n         amount: 1,\n         currencyCode: 'USD',\n         interval: BillingInterval.Usage.\n         terms: '1 dollar per 1000 emails',\n        },\n      ],\n    },\n  }\n future: {v3_lineItemBilling: true}\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "check",
                "value": "(options: CheckBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Check what billing plans a merchant is subscribed to",
                    "description": "Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does notthrow an error if no active billing plans are present.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const { hasActivePayment, appSubscriptions } = await billing.check({\n    plans: [MONTHLY_PLAN],\n    isTest: false,\n  });\n console.log(hasActivePayment)\n console.log(appSubscriptions)\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "(options: RequestBillingOptions<Config>) => Promise<never>",
                "description": "Requests payment for the plan.",
                "examples": [
                  {
                    "title": "Using a custom return URL",
                    "description": "Change where the merchant is returned to after approving the purchase using the `returnUrl` option.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({\n      plan: MONTHLY_PLAN,\n      isTest: true,\n      returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n    }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cancel",
                "value": "(options: CancelBillingOptions) => Promise<AppSubscription>",
                "description": "Cancels an ongoing subscription, given its ID.",
                "examples": [
                  {
                    "title": "Cancelling a subscription",
                    "description": "Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  const cancelledSubscription = await billing.cancel({\n    subscriptionId: subscription.id,\n    isTest: true,\n    prorate: true,\n   });\n\n  // App logic\n};",
                        "title": "/app/routes/cancel-subscription.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface BillingContext<Config extends AppConfigArg> {\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Requesting billing right away.</caption>\n   * <description>Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Redirect to a plan selection page.</caption>\n   * <description> When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n   *     isTest: true,\n   *     onFailure: () => redirect('/select-plan'),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   * @example\n   * <caption>Requesting billing with line items</caption>\n   * <description>Call `billing.request` with the `v3_lineItemBilling` future flag enabled</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       lineItems: [\n   *        {\n   *          amount: 5,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Every30Days,\n   *         },\n   *         {\n   *          amount: 1,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Usage.\n   *          terms: '1 dollar per 1000 emails',\n   *         },\n   *       ],\n   *     },\n   *   }\n   *  future: {v3_lineItemBilling: true}\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  require: (\n    options: RequireBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Check what billing plans a merchant is subscribed to.</caption>\n   * <description>Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does not\n   * throw an error if no active billing plans are present. </description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const { hasActivePayment, appSubscriptions } = await billing.check({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: false,\n   *   });\n   *  console.log(hasActivePayment)\n   *  console.log(appSubscriptions)\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   */\n  check: (\n    options: CheckBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Requests payment for the plan.\n   *\n   * @returns Redirects to the confirmation URL for the payment.\n   *\n   * @example\n   * <caption>Using a custom return URL.</caption>\n   * <description>Change where the merchant is returned to after approving the purchase using the `returnUrl` option.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({\n   *       plan: MONTHLY_PLAN,\n   *       isTest: true,\n   *       returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n   *     }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  request: (options: RequestBillingOptions<Config>) => Promise<never>;\n\n  /**\n   * Cancels an ongoing subscription, given its ID.\n   *\n   * @returns The cancelled subscription.\n   *\n   * @example\n   * <caption>Cancelling a subscription.</caption>\n   * <description>Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.</description>\n   * ```ts\n   * // /app/routes/cancel-subscription.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   const cancelledSubscription = await billing.cancel({\n   *     subscriptionId: subscription.id,\n   *     isTest: true,\n   *     prorate: true,\n   *    });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  cancel: (options: CancelBillingOptions) => Promise<AppSubscription>;\n}"
          },
          "RequireBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequireBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onFailure",
                "value": "(error: any) => Promise<Response>",
                "description": "How to handle the request if the shop doesn't have an active payment for any plan."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface RequireBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n  /**\n   * How to handle the request if the shop doesn't have an active payment for any plan.\n   */\n  onFailure: (error: any) => Promise<Response>;\n}"
          },
          "BillingCheckResponseObject": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingCheckResponseObject",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hasActivePayment",
                "value": "boolean",
                "description": "Whether the user has an active payment method."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "oneTimePurchases",
                "value": "OneTimePurchase[]",
                "description": "The one-time purchases the shop has."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "appSubscriptions",
                "value": "AppSubscription[]",
                "description": "The active subscriptions the shop has."
              }
            ],
            "value": "export interface BillingCheckResponseObject {\n  /**\n   * Whether the user has an active payment method.\n   */\n  hasActivePayment: boolean;\n  /**\n   * The one-time purchases the shop has.\n   */\n  oneTimePurchases: OneTimePurchase[];\n  /**\n   * The active subscriptions the shop has.\n   */\n  appSubscriptions: AppSubscription[];\n}"
          },
          "OneTimePurchase": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "OneTimePurchase",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the one-time purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "status",
                "value": "string",
                "description": "The status of the one-time purchase."
              }
            ],
            "value": "export interface OneTimePurchase {\n  /**\n   * The ID of the one-time purchase.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  test: boolean;\n  /**\n   * The status of the one-time purchase.\n   */\n  status: string;\n}"
          },
          "AppSubscription": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppSubscription",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the app subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "lineItems",
                "value": "ActiveSubscriptionLineItem[]",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface AppSubscription {\n  /**\n   * The ID of the app subscription.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test subscription.\n   */\n  test: boolean;\n\n  /*\n   * The line items for this plan. This will become mandatory in v10.\n   */\n  lineItems?: ActiveSubscriptionLineItem[];\n}"
          },
          "ActiveSubscriptionLineItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "ActiveSubscriptionLineItem",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "AppPlan",
                "description": ""
              }
            ],
            "value": "export interface ActiveSubscriptionLineItem {\n  /*\n   * The ID of the line item.\n   */\n  id: string;\n  /*\n   * The details of the plan.\n   */\n  plan: AppPlan;\n}"
          },
          "AppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pricingDetails",
                "value": "RecurringAppPlan | UsageAppPlan",
                "description": ""
              }
            ],
            "value": "export interface AppPlan {\n  /*\n   * The pricing details of the plan.\n   */\n  pricingDetails: RecurringAppPlan | UsageAppPlan;\n}"
          },
          "RecurringAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "RecurringAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Every30Days | BillingInterval.Annual",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "discount",
                "value": "AppPlanDiscount",
                "description": ""
              }
            ],
            "value": "export interface RecurringAppPlan {\n  /*\n   * The interval for this plan is charged on.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /*\n   * The price of the plan.\n   */\n  price: Money;\n  /*\n   * The discount applied to the plan.\n   */\n  discount: AppPlanDiscount;\n}"
          },
          "BillingInterval": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "BillingInterval",
            "value": "export enum BillingInterval {\n  OneTime = 'ONE_TIME',\n  Every30Days = 'EVERY_30_DAYS',\n  Annual = 'ANNUAL',\n  Usage = 'USAGE',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "OneTime",
                "value": "ONE_TIME"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Every30Days",
                "value": "EVERY_30_DAYS"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Annual",
                "value": "ANNUAL"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Usage",
                "value": "USAGE"
              }
            ]
          },
          "Money": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "Money",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": ""
              }
            ],
            "value": "interface Money {\n  amount: number;\n  currencyCode: string;\n}"
          },
          "AppPlanDiscount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlanDiscount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "durationLimitInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "remainingDurationInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "priceAfterDiscount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "AppPlanDiscountAmount",
                "description": ""
              }
            ],
            "value": "export interface AppPlanDiscount {\n  /*\n   * The total number of intervals the discount applies to.\n   */\n  durationLimitInIntervals: number;\n  /*\n   * The remaining number of intervals the discount applies to.\n   */\n  remainingDurationInIntervals: number;\n  /*\n   * The price after the discount is applied.\n   */\n  priceAfterDiscount: Money;\n  /*\n   * The value of the discount applied every billing interval.\n   */\n  value: AppPlanDiscountAmount;\n}"
          },
          "AppPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AppPlanDiscountAmount",
            "value": "BillingConfigSubscriptionPlanDiscountAmount | BillingConfigSubscriptionPlanDiscountPercentage",
            "description": ""
          },
          "BillingConfigSubscriptionPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountAmount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "never",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set.",
                "isOptional": true
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountAmount {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount: number;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage?: never;\n}"
          },
          "BillingConfigSubscriptionPlanDiscountPercentage": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountPercentage",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "never",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "number",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set."
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountPercentage {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount?: never;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage: number;\n}"
          },
          "UsageAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "UsageAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "balanceUsed",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cappedAmount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "terms",
                "value": "string",
                "description": ""
              }
            ],
            "value": "export interface UsageAppPlan {\n  /*\n   * The total usage records for interval.\n   */\n  balanceUsed: Money;\n  /*\n   * The capped amount prevents the merchant from being charged for any usage over that amount during a billing period.\n   */\n  cappedAmount: Money;\n  /*\n   * The terms and conditions for app usage pricing.\n   */\n  terms: string;\n}"
          },
          "CheckBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CheckBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface CheckBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n}"
          },
          "RequestBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequestBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "keyof Config[\"billing\"]",
                "description": "The plan to request. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "returnUrl",
                "value": "string",
                "description": "The URL to return to after the merchant approves the payment.",
                "isOptional": true
              }
            ],
            "value": "export interface RequestBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingRequestParams, 'session' | 'plan' | 'returnObject'> {\n  /**\n   * The plan to request. Must be one of the values defined in the `billing` config option.\n   */\n  plan: keyof Config['billing'];\n  /**\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n  /**\n   * The URL to return to after the merchant approves the payment.\n   */\n  returnUrl?: string;\n}"
          },
          "CancelBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CancelBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subscriptionId",
                "value": "string",
                "description": "The ID of the subscription to cancel."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "prorate",
                "value": "boolean",
                "description": "Whether to prorate the cancellation.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface CancelBillingOptions {\n  /**\n   * The ID of the subscription to cancel.\n   */\n  subscriptionId: string;\n  /**\n   * Whether to prorate the cancellation.\n   *\n   * {@link https://shopify.dev/docs/apps/billing/subscriptions/cancel-recurring-charges}\n   */\n  prorate?: boolean;\n  /*\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n}"
          },
          "EnsureCORSFunction": {
            "filePath": "src/server/authenticate/helpers/ensure-cors-headers.ts",
            "name": "EnsureCORSFunction",
            "description": "",
            "members": [],
            "value": "export interface EnsureCORSFunction {\n  (response: Response): Response;\n}"
          },
          "EmbeddedAdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "EmbeddedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionToken",
                "value": "JwtPayload",
                "description": "The decoded and validated session token for the request.\n\nReturned only if `isEmbeddedApp` is `true`.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using the decoded session token",
                    "description": "Get user-specific data using the `sessionToken` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken } = await authenticate.admin(\n    request\n  );\n  return json(await getMyAppData({user: sessionToken.sub}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "redirect",
                "value": "RedirectFunction",
                "description": "A function that redirects the user to a new page, ensuring that the appropriate parameters are set for embedded apps.\n\nReturned only if `isEmbeddedApp` is `true`.",
                "examples": [
                  {
                    "title": "Redirecting to an app route",
                    "description": "Use the `redirect` helper to safely redirect between pages.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\");\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirecting outside of Shopify admin",
                    "description": "Pass in a `target` option of `_top` or `_parent` to go to an external URL.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\", { target: '_parent' });\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the user who made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using offline sessions",
                    "description": "Get your app's shop-specific data using an offline session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Using online sessions",
                    "description": "Get your app's user-specific data using an online session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request."
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingContext<Config>",
                "description": "Billing methods for this store, based on the plans defined in the `billing` config option.\n\n\n\n\n"
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a admin request",
                    "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface EmbeddedAdminContext<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends AdminContextInternal<Config, Resources> {\n  /**\n   * The decoded and validated session token for the request.\n   *\n   * Returned only if `isEmbeddedApp` is `true`.\n   *\n   * {@link https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload}\n   *\n   * @example\n   * <caption>Using the decoded session token.</caption>\n   * <description>Get user-specific data using the `sessionToken` object.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken } = await authenticate.admin(\n   *     request\n   *   );\n   *   return json(await getMyAppData({user: sessionToken.sub}));\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   useOnlineTokens: true,\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  sessionToken: JwtPayload;\n\n  /**\n   * A function that redirects the user to a new page, ensuring that the appropriate parameters are set for embedded\n   * apps.\n   *\n   * Returned only if `isEmbeddedApp` is `true`.\n   *\n   * @example\n   * <caption>Redirecting to an app route.</caption>\n   * <description>Use the `redirect` helper to safely redirect between pages.</description>\n   * ```ts\n   * // /app/routes/admin/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { session, redirect } = await authenticate.admin(request);\n   *   return redirect(\"/\");\n   * };\n   * ```\n   *\n   * @example\n   * <caption>Redirecting outside of Shopify admin.</caption>\n   * <description>Pass in a `target` option of `_top` or `_parent` to go to an external URL.</description>\n   * ```ts\n   * // /app/routes/admin/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { session, redirect } = await authenticate.admin(request);\n   *   return redirect(\"/\", { target: '_parent' });\n   * };\n   * ```\n   */\n  redirect: RedirectFunction;\n}"
          },
          "JwtPayload": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "JwtPayload",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iss",
                "value": "string",
                "description": "The shop's admin domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "dest",
                "value": "string",
                "description": "The shop's domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "aud",
                "value": "string",
                "description": "The client ID of the receiving app."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sub",
                "value": "string",
                "description": "The User that the session token is intended for."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "exp",
                "value": "number",
                "description": "When the session token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nbf",
                "value": "number",
                "description": "When the session token activates."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iat",
                "value": "number",
                "description": "When the session token was issued."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "jti",
                "value": "string",
                "description": "A secure random UUID."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sid",
                "value": "string",
                "description": "A unique session ID per user and app."
              }
            ],
            "value": "export interface JwtPayload {\n  /**\n   * The shop's admin domain.\n   */\n  iss: string;\n  /**\n   * The shop's domain.\n   */\n  dest: string;\n  /**\n   * The client ID of the receiving app.\n   */\n  aud: string;\n  /**\n   * The User that the session token is intended for.\n   */\n  sub: string;\n  /**\n   * When the session token expires.\n   */\n  exp: number;\n  /**\n   * When the session token activates.\n   */\n  nbf: number;\n  /**\n   * When the session token was issued.\n   */\n  iat: number;\n  /**\n   * A secure random UUID.\n   */\n  jti: string;\n  /**\n   * A unique session ID per user and app.\n   */\n  sid: string;\n}"
          },
          "RedirectFunction": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "name": "RedirectFunction",
            "description": "",
            "params": [
              {
                "name": "url",
                "description": "",
                "value": "string",
                "filePath": "src/server/authenticate/admin/helpers/redirect.ts"
              },
              {
                "name": "init",
                "description": "",
                "value": "RedirectInit",
                "isOptional": true,
                "filePath": "src/server/authenticate/admin/helpers/redirect.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
              "description": "",
              "name": "TypedResponse<never>",
              "value": "TypedResponse<never>"
            },
            "value": "export type RedirectFunction = (\n  url: string,\n  init?: RedirectInit,\n) => TypedResponse<never>;"
          },
          "RedirectInit": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RedirectInit",
            "value": "number | (ResponseInit & {target?: RedirectTarget})",
            "description": ""
          },
          "RedirectTarget": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RedirectTarget",
            "value": "'_self' | '_parent' | '_top'",
            "description": ""
          }
        }
      }
    ],
    "defaultExample": {
      "description": "Authenticate, run API mutation, and redirect",
      "codeblock": {
        "title": "Authenticate, run API mutation, and redirect",
        "tabs": [
          {
            "title": "/app/routes/**.ts",
            "language": "typescript",
            "code": "import {type ActionFunctionArgs, json} from '@remix-run/node';\nimport {GraphqlQueryError} from '@shopify/shopify-api';\n\nimport {authenticate} from '../shopify.server';\n\nexport const action = async ({request}: ActionFunctionArgs) =&gt; {\n  const {admin, redirect} = await authenticate.admin(request);\n\n  try {\n    await admin.graphql(\n      `#graphql\n      mutation updateProductTitle($input: ProductInput!) {\n        productUpdate(input: $input) {\n          product {\n            id\n          }\n        }\n      }`,\n      {\n        variables: {\n          input: {id: '123', title: 'New title'},\n        },\n      },\n    );\n\n    return redirect('/app/product-updated');\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      return json({errors: error.body?.errors}, {status: 500});\n    }\n\n    return new Response('Failed to update product title', {status: 500});\n  }\n};\n"
          }
        ]
      }
    },
    "jsDocTypeExamples": [
      "EmbeddedAdminContext",
      "AdminApiContext",
      "BillingContext"
    ],
    "related": [
      {
        "name": "API context",
        "subtitle": "Interact with the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/admin-api"
      },
      {
        "name": "Billing context",
        "subtitle": "Bill merchants for your app using the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/billing"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "sessionToken",
          "examples": [
            {
              "description": "Get user-specific data using the `sessionToken` object.",
              "codeblock": {
                "title": "Using the decoded session token",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { sessionToken } = await authenticate.admin(\n    request\n  );\n  return json(await getMyAppData({user: sessionToken.sub}));\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "redirect",
          "examples": [
            {
              "description": "Use the `redirect` helper to safely redirect between pages.",
              "codeblock": {
                "title": "Redirecting to an app route",
                "tabs": [
                  {
                    "title": "/app/routes/admin/my-route.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\");\n};",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Pass in a `target` option of `_top` or `_parent` to go to an external URL.",
              "codeblock": {
                "title": "Redirecting outside of Shopify admin",
                "tabs": [
                  {
                    "title": "/app/routes/admin/my-route.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\", { target: '_parent' });\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "session",
          "examples": [
            {
              "description": "Get your app's shop-specific data using an offline session.",
              "codeblock": {
                "title": "Using offline sessions",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Get your app's user-specific data using an online session.",
              "codeblock": {
                "title": "Using online sessions",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "cors",
          "examples": [
            {
              "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
              "codeblock": {
                "title": "Setting CORS headers for a admin request",
                "tabs": [
                  {
                    "title": "/app/routes/admin/my-route.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "rest",
          "examples": [
            {
              "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
              "codeblock": {
                "title": "Using REST resources",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
              "codeblock": {
                "title": "Performing a GET request to the REST API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
              "codeblock": {
                "title": "Performing a POST request to the REST API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "graphql",
          "examples": [
            {
              "description": "Use `admin.graphql` to make query / mutation requests.",
              "codeblock": {
                "title": "Querying the GraphQL API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
              "codeblock": {
                "title": "Handling GraphQL errors",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "require",
          "examples": [
            {
              "description": "Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.",
              "codeblock": {
                "title": "Requesting billing right away",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () =&gt; billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.",
              "codeblock": {
                "title": "Redirect to a plan selection page",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n    isTest: true,\n    onFailure: () =&gt; redirect('/select-plan'),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Call `billing.request` with the `v3_lineItemBilling` future flag enabled",
              "codeblock": {
                "title": "Requesting billing with line items",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () =&gt; billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      lineItems: [\n       {\n         amount: 5,\n         currencyCode: 'USD',\n         interval: BillingInterval.Every30Days,\n        },\n        {\n         amount: 1,\n         currencyCode: 'USD',\n         interval: BillingInterval.Usage.\n         terms: '1 dollar per 1000 emails',\n        },\n      ],\n    },\n  }\n future: {v3_lineItemBilling: true}\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "check",
          "examples": [
            {
              "description": "Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does notthrow an error if no active billing plans are present.",
              "codeblock": {
                "title": "Check what billing plans a merchant is subscribed to",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  const { hasActivePayment, appSubscriptions } = await billing.check({\n    plans: [MONTHLY_PLAN],\n    isTest: false,\n  });\n console.log(hasActivePayment)\n console.log(appSubscriptions)\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "request",
          "examples": [
            {
              "description": "Change where the merchant is returned to after approving the purchase using the `returnUrl` option.",
              "codeblock": {
                "title": "Using a custom return URL",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () =&gt; billing.request({\n      plan: MONTHLY_PLAN,\n      isTest: true,\n      returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n    }),\n  });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "cancel",
          "examples": [
            {
              "description": "Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.",
              "codeblock": {
                "title": "Cancelling a subscription",
                "tabs": [
                  {
                    "title": "/app/routes/cancel-subscription.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () =&gt; billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  const cancelledSubscription = await billing.cancel({\n    subscriptionId: subscription.id,\n    isTest: true,\n    prorate: true,\n   });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Billing",
    "description": "Contains function used to bill merchants for your app.\n\nThis object is returned on authenticated Admin requests.",
    "category": "APIs",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "billing",
        "description": "Provides utilities that apps can use to request billing for the app using the Admin API.",
        "type": "BillingContext",
        "typeDefinitions": {
          "BillingContext": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "BillingContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "require",
                "value": "(options: RequireBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Requesting billing right away",
                    "description": "Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirect to a plan selection page",
                    "description": "When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n    isTest: true,\n    onFailure: () => redirect('/select-plan'),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Requesting billing with line items",
                    "description": "Call `billing.request` with the `v3_lineItemBilling` future flag enabled",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      lineItems: [\n       {\n         amount: 5,\n         currencyCode: 'USD',\n         interval: BillingInterval.Every30Days,\n        },\n        {\n         amount: 1,\n         currencyCode: 'USD',\n         interval: BillingInterval.Usage.\n         terms: '1 dollar per 1000 emails',\n        },\n      ],\n    },\n  }\n future: {v3_lineItemBilling: true}\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "check",
                "value": "(options: CheckBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Check what billing plans a merchant is subscribed to",
                    "description": "Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does notthrow an error if no active billing plans are present.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const { hasActivePayment, appSubscriptions } = await billing.check({\n    plans: [MONTHLY_PLAN],\n    isTest: false,\n  });\n console.log(hasActivePayment)\n console.log(appSubscriptions)\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "(options: RequestBillingOptions<Config>) => Promise<never>",
                "description": "Requests payment for the plan.",
                "examples": [
                  {
                    "title": "Using a custom return URL",
                    "description": "Change where the merchant is returned to after approving the purchase using the `returnUrl` option.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({\n      plan: MONTHLY_PLAN,\n      isTest: true,\n      returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n    }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cancel",
                "value": "(options: CancelBillingOptions) => Promise<AppSubscription>",
                "description": "Cancels an ongoing subscription, given its ID.",
                "examples": [
                  {
                    "title": "Cancelling a subscription",
                    "description": "Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  const cancelledSubscription = await billing.cancel({\n    subscriptionId: subscription.id,\n    isTest: true,\n    prorate: true,\n   });\n\n  // App logic\n};",
                        "title": "/app/routes/cancel-subscription.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface BillingContext<Config extends AppConfigArg> {\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Requesting billing right away.</caption>\n   * <description>Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Redirect to a plan selection page.</caption>\n   * <description> When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n   *     isTest: true,\n   *     onFailure: () => redirect('/select-plan'),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   * @example\n   * <caption>Requesting billing with line items</caption>\n   * <description>Call `billing.request` with the `v3_lineItemBilling` future flag enabled</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       lineItems: [\n   *        {\n   *          amount: 5,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Every30Days,\n   *         },\n   *         {\n   *          amount: 1,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Usage.\n   *          terms: '1 dollar per 1000 emails',\n   *         },\n   *       ],\n   *     },\n   *   }\n   *  future: {v3_lineItemBilling: true}\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  require: (\n    options: RequireBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Check what billing plans a merchant is subscribed to.</caption>\n   * <description>Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does not\n   * throw an error if no active billing plans are present. </description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const { hasActivePayment, appSubscriptions } = await billing.check({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: false,\n   *   });\n   *  console.log(hasActivePayment)\n   *  console.log(appSubscriptions)\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   */\n  check: (\n    options: CheckBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Requests payment for the plan.\n   *\n   * @returns Redirects to the confirmation URL for the payment.\n   *\n   * @example\n   * <caption>Using a custom return URL.</caption>\n   * <description>Change where the merchant is returned to after approving the purchase using the `returnUrl` option.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({\n   *       plan: MONTHLY_PLAN,\n   *       isTest: true,\n   *       returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n   *     }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  request: (options: RequestBillingOptions<Config>) => Promise<never>;\n\n  /**\n   * Cancels an ongoing subscription, given its ID.\n   *\n   * @returns The cancelled subscription.\n   *\n   * @example\n   * <caption>Cancelling a subscription.</caption>\n   * <description>Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.</description>\n   * ```ts\n   * // /app/routes/cancel-subscription.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   const cancelledSubscription = await billing.cancel({\n   *     subscriptionId: subscription.id,\n   *     isTest: true,\n   *     prorate: true,\n   *    });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  cancel: (options: CancelBillingOptions) => Promise<AppSubscription>;\n}"
          },
          "RequireBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequireBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onFailure",
                "value": "(error: any) => Promise<Response>",
                "description": "How to handle the request if the shop doesn't have an active payment for any plan."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface RequireBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n  /**\n   * How to handle the request if the shop doesn't have an active payment for any plan.\n   */\n  onFailure: (error: any) => Promise<Response>;\n}"
          },
          "BillingCheckResponseObject": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingCheckResponseObject",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hasActivePayment",
                "value": "boolean",
                "description": "Whether the user has an active payment method."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "oneTimePurchases",
                "value": "OneTimePurchase[]",
                "description": "The one-time purchases the shop has."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "appSubscriptions",
                "value": "AppSubscription[]",
                "description": "The active subscriptions the shop has."
              }
            ],
            "value": "export interface BillingCheckResponseObject {\n  /**\n   * Whether the user has an active payment method.\n   */\n  hasActivePayment: boolean;\n  /**\n   * The one-time purchases the shop has.\n   */\n  oneTimePurchases: OneTimePurchase[];\n  /**\n   * The active subscriptions the shop has.\n   */\n  appSubscriptions: AppSubscription[];\n}"
          },
          "OneTimePurchase": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "OneTimePurchase",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the one-time purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "status",
                "value": "string",
                "description": "The status of the one-time purchase."
              }
            ],
            "value": "export interface OneTimePurchase {\n  /**\n   * The ID of the one-time purchase.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  test: boolean;\n  /**\n   * The status of the one-time purchase.\n   */\n  status: string;\n}"
          },
          "AppSubscription": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppSubscription",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the app subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "lineItems",
                "value": "ActiveSubscriptionLineItem[]",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface AppSubscription {\n  /**\n   * The ID of the app subscription.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test subscription.\n   */\n  test: boolean;\n\n  /*\n   * The line items for this plan. This will become mandatory in v10.\n   */\n  lineItems?: ActiveSubscriptionLineItem[];\n}"
          },
          "ActiveSubscriptionLineItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "ActiveSubscriptionLineItem",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "AppPlan",
                "description": ""
              }
            ],
            "value": "export interface ActiveSubscriptionLineItem {\n  /*\n   * The ID of the line item.\n   */\n  id: string;\n  /*\n   * The details of the plan.\n   */\n  plan: AppPlan;\n}"
          },
          "AppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pricingDetails",
                "value": "RecurringAppPlan | UsageAppPlan",
                "description": ""
              }
            ],
            "value": "export interface AppPlan {\n  /*\n   * The pricing details of the plan.\n   */\n  pricingDetails: RecurringAppPlan | UsageAppPlan;\n}"
          },
          "RecurringAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "RecurringAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Every30Days | BillingInterval.Annual",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "discount",
                "value": "AppPlanDiscount",
                "description": ""
              }
            ],
            "value": "export interface RecurringAppPlan {\n  /*\n   * The interval for this plan is charged on.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /*\n   * The price of the plan.\n   */\n  price: Money;\n  /*\n   * The discount applied to the plan.\n   */\n  discount: AppPlanDiscount;\n}"
          },
          "BillingInterval": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "BillingInterval",
            "value": "export enum BillingInterval {\n  OneTime = 'ONE_TIME',\n  Every30Days = 'EVERY_30_DAYS',\n  Annual = 'ANNUAL',\n  Usage = 'USAGE',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "OneTime",
                "value": "ONE_TIME"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Every30Days",
                "value": "EVERY_30_DAYS"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Annual",
                "value": "ANNUAL"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Usage",
                "value": "USAGE"
              }
            ]
          },
          "Money": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "Money",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": ""
              }
            ],
            "value": "interface Money {\n  amount: number;\n  currencyCode: string;\n}"
          },
          "AppPlanDiscount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlanDiscount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "durationLimitInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "remainingDurationInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "priceAfterDiscount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "AppPlanDiscountAmount",
                "description": ""
              }
            ],
            "value": "export interface AppPlanDiscount {\n  /*\n   * The total number of intervals the discount applies to.\n   */\n  durationLimitInIntervals: number;\n  /*\n   * The remaining number of intervals the discount applies to.\n   */\n  remainingDurationInIntervals: number;\n  /*\n   * The price after the discount is applied.\n   */\n  priceAfterDiscount: Money;\n  /*\n   * The value of the discount applied every billing interval.\n   */\n  value: AppPlanDiscountAmount;\n}"
          },
          "AppPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AppPlanDiscountAmount",
            "value": "BillingConfigSubscriptionPlanDiscountAmount | BillingConfigSubscriptionPlanDiscountPercentage",
            "description": ""
          },
          "BillingConfigSubscriptionPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountAmount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "never",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set.",
                "isOptional": true
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountAmount {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount: number;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage?: never;\n}"
          },
          "BillingConfigSubscriptionPlanDiscountPercentage": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountPercentage",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "never",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "number",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set."
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountPercentage {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount?: never;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage: number;\n}"
          },
          "UsageAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "UsageAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "balanceUsed",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cappedAmount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "terms",
                "value": "string",
                "description": ""
              }
            ],
            "value": "export interface UsageAppPlan {\n  /*\n   * The total usage records for interval.\n   */\n  balanceUsed: Money;\n  /*\n   * The capped amount prevents the merchant from being charged for any usage over that amount during a billing period.\n   */\n  cappedAmount: Money;\n  /*\n   * The terms and conditions for app usage pricing.\n   */\n  terms: string;\n}"
          },
          "CheckBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CheckBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface CheckBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n}"
          },
          "RequestBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequestBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "keyof Config[\"billing\"]",
                "description": "The plan to request. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "returnUrl",
                "value": "string",
                "description": "The URL to return to after the merchant approves the payment.",
                "isOptional": true
              }
            ],
            "value": "export interface RequestBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingRequestParams, 'session' | 'plan' | 'returnObject'> {\n  /**\n   * The plan to request. Must be one of the values defined in the `billing` config option.\n   */\n  plan: keyof Config['billing'];\n  /**\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n  /**\n   * The URL to return to after the merchant approves the payment.\n   */\n  returnUrl?: string;\n}"
          },
          "CancelBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CancelBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subscriptionId",
                "value": "string",
                "description": "The ID of the subscription to cancel."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "prorate",
                "value": "boolean",
                "description": "Whether to prorate the cancellation.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface CancelBillingOptions {\n  /**\n   * The ID of the subscription to cancel.\n   */\n  subscriptionId: string;\n  /**\n   * Whether to prorate the cancellation.\n   *\n   * {@link https://shopify.dev/docs/apps/billing/subscriptions/cancel-recurring-charges}\n   */\n  prorate?: boolean;\n  /*\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n}"
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "BillingContext"
    ],
    "related": [
      {
        "name": "Admin context",
        "subtitle": "Authenticate requests from Shopify Admin.",
        "url": "/docs/api/shopify-app-remix/authenticate/admin"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "require",
          "examples": [
            {
              "description": "Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.",
              "codeblock": {
                "title": "Requesting billing right away",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () =&gt; billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.",
              "codeblock": {
                "title": "Redirect to a plan selection page",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n    isTest: true,\n    onFailure: () =&gt; redirect('/select-plan'),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Call `billing.request` with the `v3_lineItemBilling` future flag enabled",
              "codeblock": {
                "title": "Requesting billing with line items",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () =&gt; billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      lineItems: [\n       {\n         amount: 5,\n         currencyCode: 'USD',\n         interval: BillingInterval.Every30Days,\n        },\n        {\n         amount: 1,\n         currencyCode: 'USD',\n         interval: BillingInterval.Usage.\n         terms: '1 dollar per 1000 emails',\n        },\n      ],\n    },\n  }\n future: {v3_lineItemBilling: true}\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "check",
          "examples": [
            {
              "description": "Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does notthrow an error if no active billing plans are present.",
              "codeblock": {
                "title": "Check what billing plans a merchant is subscribed to",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  const { hasActivePayment, appSubscriptions } = await billing.check({\n    plans: [MONTHLY_PLAN],\n    isTest: false,\n  });\n console.log(hasActivePayment)\n console.log(appSubscriptions)\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "request",
          "examples": [
            {
              "description": "Change where the merchant is returned to after approving the purchase using the `returnUrl` option.",
              "codeblock": {
                "title": "Using a custom return URL",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () =&gt; billing.request({\n      plan: MONTHLY_PLAN,\n      isTest: true,\n      returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n    }),\n  });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "cancel",
          "examples": [
            {
              "description": "Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.",
              "codeblock": {
                "title": "Cancelling a subscription",
                "tabs": [
                  {
                    "title": "/app/routes/cancel-subscription.ts",
                    "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () =&gt; billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  const cancelledSubscription = await billing.cancel({\n    subscriptionId: subscription.id,\n    isTest: true,\n    prorate: true,\n   });\n\n  // App logic\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "shopify.server.ts",
                    "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Flow",
    "description": "Contains functions for verifying Shopify Flow extensions.\n\nSee the [Flow documentation](https://shopify.dev/docs/apps/flow/actions/endpoints) for more information.",
    "category": "Authenticate",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "authenticate.flow",
        "description": "Verifies requests coming from Shopify Flow extensions.",
        "type": "AuthenticateFlow",
        "typeDefinitions": {
          "AuthenticateFlow": {
            "filePath": "src/server/authenticate/flow/types.ts",
            "name": "AuthenticateFlow",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/flow/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/flow/types.ts",
              "description": "",
              "name": "Promise<FlowContext<Resources>>",
              "value": "Promise<FlowContext<Resources>>"
            },
            "value": "export type AuthenticateFlow<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> = (request: Request) => Promise<FlowContext<Resources>>;"
          },
          "FlowContext": {
            "filePath": "src/server/authenticate/flow/types.ts",
            "name": "FlowContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/flow/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "A session with an offline token for the shop.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Shopify session for the Flow request",
                    "description": "Use the session associated with this request to use REST resources.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { session, admin } = await authenticate.flow(request);\n\n  const products = await admin?.rest.resources.Product.all({ session });\n  // Use products\n\n  return new Response();\n};",
                        "title": "/app/routes/flow.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/flow/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "any",
                "description": "The payload from the Flow request.",
                "examples": [
                  {
                    "title": "Flow payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { payload } = await authenticate.flow(request);\n  return new Response();\n};",
                        "title": "/app/routes/flow.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/flow/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "An admin context for the Flow request.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Flow admin context",
                    "description": "Use the `admin` object in the context to interact with the Admin API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.flow(request);\n\n  const response = await admin?.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/flow.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface FlowContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * A session with an offline token for the shop.\n   *\n   * Returned only if there is a session for the shop.\n   *\n   * @example\n   * <caption>Shopify session for the Flow request.</caption>\n   * <description>Use the session associated with this request to use REST resources.</description>\n   * ```ts\n   * // /app/routes/flow.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { session, admin } = await authenticate.flow(request);\n   *\n   *   const products = await admin?.rest.resources.Product.all({ session });\n   *   // Use products\n   *\n   *   return new Response();\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * The payload from the Flow request.\n   *\n   * @example\n   * <caption>Flow payload.</caption>\n   * <description>Get the request's POST payload.</description>\n   * ```ts\n   * // /app/routes/flow.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { payload } = await authenticate.flow(request);\n   *   return new Response();\n   * };\n   * ```\n   */\n  payload: any;\n\n  /**\n   * An admin context for the Flow request.\n   *\n   * Returned only if there is a session for the shop.\n   *\n   * @example\n   * <caption>Flow admin context.</caption>\n   * <description>Use the `admin` object in the context to interact with the Admin API.</description>\n   * ```ts\n   * // /app/routes/flow.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.flow(request);\n   *\n   *   const response = await admin?.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     { variables: { input: { title: \"Product Name\" } } }\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          }
        }
      }
    ],
    "defaultExample": {
      "description": "Handle a flow action call",
      "codeblock": {
        "title": "Set a metafield on a customer after a flow call",
        "tabs": [
          {
            "title": "/app/routes/**.ts",
            "language": "typescript",
            "code": "import {type ActionFunctionArgs} from '@remix-run/node';\n\nimport {authenticate} from '../shopify.server';\n\nexport const action = async ({request}: ActionFunctionArgs) =&gt; {\n  const {admin, payload} = await authenticate.flow(request);\n\n  const customerId = payload.properties.customer_id;\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation setMetafield($customerId: ID!, $time: String!) {\n      metafieldsSet(metafields: {\n        ownerId: $customerId\n        namespace: \"my-app\",\n        key: \"last_flow_update\",\n        value: $time,\n        type: \"string\",\n      }) {\n        metafields {\n          key\n          value\n        }\n      }\n    }\n    `,\n    {\n      variables: {\n        customerId,\n        time: new Date().toISOString(),\n      },\n    },\n  );\n  const body = await response.json();\n\n  console.log('Updated value', body.data!.metafieldsSet!.metafields![0].value);\n\n  return new Response();\n};\n"
          }
        ]
      }
    },
    "jsDocTypeExamples": [
      "FlowContext"
    ],
    "related": [
      {
        "name": "Admin API context",
        "subtitle": "Interact with the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/admin-api"
      },
      {
        "name": "Flow action endpoints",
        "subtitle": "Receive requests from Flow.",
        "url": "/docs/apps/flow/actions/endpoints",
        "type": "shopify"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "session",
          "examples": [
            {
              "description": "Use the session associated with this request to use REST resources.",
              "codeblock": {
                "title": "Shopify session for the Flow request",
                "tabs": [
                  {
                    "title": "/app/routes/flow.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { session, admin } = await authenticate.flow(request);\n\n  const products = await admin?.rest.resources.Product.all({ session });\n  // Use products\n\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "payload",
          "examples": [
            {
              "description": "Get the request's POST payload.",
              "codeblock": {
                "title": "Flow payload",
                "tabs": [
                  {
                    "title": "/app/routes/flow.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { payload } = await authenticate.flow(request);\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "admin",
          "examples": [
            {
              "description": "Use the `admin` object in the context to interact with the Admin API.",
              "codeblock": {
                "title": "Flow admin context",
                "tabs": [
                  {
                    "title": "/app/routes/flow.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.flow(request);\n\n  const response = await admin?.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Fulfillment Service",
    "description": "Contains functions for verifying fulfillment service requests.\n\nSee the [fulfillment service documentation](https://shopify.dev/docs/apps/fulfillment/fulfillment-service-apps) for more information.",
    "category": "Authenticate",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "authenticate.fulfillmentService",
        "description": "Verifies requests coming from Shopify to fulfillment service apps",
        "type": "AuthenticateFulfillmentService",
        "typeDefinitions": {
          "AuthenticateFulfillmentService": {
            "filePath": "src/server/authenticate/fulfillment-service/types.ts",
            "name": "AuthenticateFulfillmentService",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/fulfillment-service/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/fulfillment-service/types.ts",
              "description": "",
              "name": "Promise<FulfillmentServiceContext<Resources>>",
              "value": "Promise<FulfillmentServiceContext<Resources>>"
            },
            "value": "export type AuthenticateFulfillmentService<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> = (request: Request) => Promise<FulfillmentServiceContext<Resources>>;"
          },
          "FulfillmentServiceContext": {
            "filePath": "src/server/authenticate/fulfillment-service/types.ts",
            "name": "FulfillmentServiceContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/fulfillment-service/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "A session with an offline token for the shop.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Shopify session for the fulfillment service notification request",
                    "description": "Use the session associated with this request to use REST resources.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\n  export const action = async ({ request }: ActionFunctionArgs) => {\n  const { session, admin } = await authenticate.fulfillmentService(request);\n\n  const products = await admin?.rest.resources.Product.all({ session });\n  // Use products\n\n  return new Response();\n};",
                        "title": "/app/routes/fulfillment_service_notification.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/fulfillment-service/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "\nAn admin context for the fulfillment service request.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Shopify session for the fulfillment service request",
                    "description": "Use the session associated with this request to use the Admin GraphQL API",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.fulfillmentService(request);\n  const response = await admin?.graphql(\n `#graphql\n   query {\n     shop {\n       assignedFulfillmentOrders(first: 10, assignmentStatus: FULFILLMENT_REQUESTED) {\n         edges {\n           node {\n             id\n             destination {\n             firstName\n             lastName\n           }\n           lineItems(first: 10) {\n             edges {\n               node {\n               id\n               productTitle\n               sku\n               remainingQuantity\n             }\n           }\n         }\n         merchantRequests(first: 10, kind: FULFILLMENT_REQUEST) {\n           edges {\n             node {\n               message\n             }\n           }\n         }\n       }\n     }\n   }\n }\n}`);\n\n  const fulfillments = await response.json();\n  return json({ data: fulfillments.data });\n}",
                        "title": "/app/routes/fulfillment_order_notification.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/fulfillment-service/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "Record<string, any> & { kind: string; }",
                "description": "The payload from the fulfillment service request.",
                "examples": [
                  {
                    "title": "Fulfillment service request payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "/app/routes/fulfillment_order_notification.ts\nimport { ActionFunction } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action: ActionFunction = async ({ request }) => {\n  const { payload } = await authenticate.fulfillmentService(request);\n  if(payload.kind === 'FULFILLMENT_REQUEST') {\n   // handle fulfillment request\n  } else if (payload.kind === 'CANCELLATION_REQUEST') {\n   // handle cancellation request\n  };\nreturn new Response();",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface FulfillmentServiceContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * A session with an offline token for the shop.\n   *\n   * Returned only if there is a session for the shop.\n   * @example\n   * <caption>Shopify session for the fulfillment service notification request.</caption>\n   * <description>Use the session associated with this request to use REST resources.</description>\n   * ```ts\n   * // /app/routes/fulfillment_service_notification.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   *   export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { session, admin } = await authenticate.fulfillmentService(request);\n   *\n   *   const products = await admin?.rest.resources.Product.all({ session });\n   *   // Use products\n   *\n   *   return new Response();\n   * };\n   * ```\n   * */\n  session: Session;\n  /**\n   *\n   * An admin context for the fulfillment service request.\n   *\n   * Returned only if there is a session for the shop.\n   * @example\n   * <caption>Shopify session for the fulfillment service request.</caption>\n   * <description>Use the session associated with this request to use the Admin GraphQL API </description>\n   * ```ts\n   * // /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.fulfillmentService(request);\n   *   const response = await admin?.graphql(\n   *  `#graphql\n   *    query {\n   *      shop {\n   *        assignedFulfillmentOrders(first: 10, assignmentStatus: FULFILLMENT_REQUESTED) {\n   *          edges {\n   *            node {\n   *              id\n   *              destination {\n   *              firstName\n   *              lastName\n   *            }\n   *            lineItems(first: 10) {\n   *              edges {\n   *                node {\n   *                id\n   *                productTitle\n   *                sku\n   *                remainingQuantity\n   *              }\n   *            }\n   *          }\n   *          merchantRequests(first: 10, kind: FULFILLMENT_REQUEST) {\n   *            edges {\n   *              node {\n   *                message\n   *              }\n   *            }\n   *          }\n   *        }\n   *      }\n   *    }\n   *  }\n   * }`);\n   *\n   *   const fulfillments = await response.json();\n   *   return json({ data: fulfillments.data });\n   * }\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n\n  /**\n   * The payload from the fulfillment service request.\n   *\n   * @example\n   * <caption>Fulfillment service request payload.</caption>\n   * <description>Get the request's POST payload.</description>\n   * ```ts\n   * /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunction } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action: ActionFunction = async ({ request }) => {\n   *   const { payload } = await authenticate.fulfillmentService(request);\n   *   if(payload.kind === 'FULFILLMENT_REQUEST') {\n   *    // handle fulfillment request\n   *   } else if (payload.kind === 'CANCELLATION_REQUEST') {\n   *    // handle cancellation request\n   *   };\n   * return new Response();\n   * ```\n   */\n  payload: Record<string, any> & {\n    kind: string;\n  };\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          }
        }
      }
    ],
    "defaultExample": {
      "description": "Handle a fulfillment service notification call",
      "codeblock": {
        "title": "Consume a fulfillment service notification request",
        "tabs": [
          {
            "title": "/app/routes/**.ts",
            "language": "typescript",
            "code": "import {type ActionFunctionArgs} from '@remix-run/node';\n\nimport {authenticate} from '../shopify.server';\n\nexport const action = async ({request}: ActionFunctionArgs) =&gt; {\n  const {admin, payload} = await authenticate.flow(request);\n\n  const kind = payload.kind;\n\n  if(kind === 'FULFILLMENT_REQUEST') {\n    const response = await admin?.graphql(\n        `#graphql\n         query {\n           shop {\n             assignedFulfillmentOrders(first: 10, assignmentStatus: FULFILLMENT_REQUESTED) {\n               edges {\n                 node {\n                   id\n                   destination {\n                   firstName\n                   lastName\n                 }\n                 lineItems(first: 10) {\n                   edges {\n                     node {\n                     id\n                     productTitle\n                     sku\n                     remainingQuantity\n                   }\n                 }\n               }\n               merchantRequests(first: 10, kind: FULFILLMENT_REQUEST) {\n                 edges {\n                   node {\n                     message\n                   }\n                 }\n               }\n             }\n           }\n         }\n       }\n      }`);\n\n        const fulfillments = await response.json();\n        console.log(fulfillments);\n  }\n\n\n  return new Response();\n};\n"
          }
        ]
      }
    },
    "jsDocTypeExamples": [
      "FulfillmentServiceContext"
    ],
    "related": [
      {
        "name": "Admin API context",
        "subtitle": "Interact with the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/admin-api"
      },
      {
        "name": "Manage Fulfillments",
        "subtitle": "Receive fulfillment requests and cancellations.",
        "url": "/docs/apps/fulfillment/fulfillment-service-apps/manage-fulfillments",
        "type": "shopify"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "session",
          "examples": [
            {
              "description": "Use the session associated with this request to use REST resources.",
              "codeblock": {
                "title": "Shopify session for the fulfillment service notification request",
                "tabs": [
                  {
                    "title": "/app/routes/fulfillment_service_notification.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\n  export const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { session, admin } = await authenticate.fulfillmentService(request);\n\n  const products = await admin?.rest.resources.Product.all({ session });\n  // Use products\n\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "admin",
          "examples": [
            {
              "description": "Use the session associated with this request to use the Admin GraphQL API",
              "codeblock": {
                "title": "Shopify session for the fulfillment service request",
                "tabs": [
                  {
                    "title": "/app/routes/fulfillment_order_notification.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.fulfillmentService(request);\n  const response = await admin?.graphql(\n `#graphql\n   query {\n     shop {\n       assignedFulfillmentOrders(first: 10, assignmentStatus: FULFILLMENT_REQUESTED) {\n         edges {\n           node {\n             id\n             destination {\n             firstName\n             lastName\n           }\n           lineItems(first: 10) {\n             edges {\n               node {\n               id\n               productTitle\n               sku\n               remainingQuantity\n             }\n           }\n         }\n         merchantRequests(first: 10, kind: FULFILLMENT_REQUEST) {\n           edges {\n             node {\n               message\n             }\n           }\n         }\n       }\n     }\n   }\n }\n}`);\n\n  const fulfillments = await response.json();\n  return json({ data: fulfillments.data });\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "payload",
          "examples": [
            {
              "description": "Get the request's POST payload.",
              "codeblock": {
                "title": "Fulfillment service request payload",
                "tabs": [
                  {
                    "title": "Example",
                    "code": "/app/routes/fulfillment_order_notification.ts\nimport { ActionFunction } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action: ActionFunction = async ({ request }) =&gt; {\n  const { payload } = await authenticate.fulfillmentService(request);\n  if(payload.kind === 'FULFILLMENT_REQUEST') {\n   // handle fulfillment request\n  } else if (payload.kind === 'CANCELLATION_REQUEST') {\n   // handle cancellation request\n  };\nreturn new Response();",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "App proxy",
    "description": "[App proxies](/docs/apps/online-store/app-proxies) take requests to Shopify links, and redirect them to external links.\nThe `authenticate.public.appProxy` function validates requests made to app proxies, and returns a context to enable querying Shopify APIs.\n\n> Note: If the store has not installed the app, store-related properties such as `admin` or `storefront` will be `undefined`",
    "category": "Authenticate",
    "subCategory": "Public",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "authenticate.public.appProxy",
        "description": "Authenticates requests coming to the app from Shopify app proxies.",
        "type": "AuthenticateAppProxy",
        "typeDefinitions": {
          "AuthenticateAppProxy": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "AuthenticateAppProxy",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/public/appProxy/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/public/appProxy/types.ts",
              "description": "",
              "name": "Promise<AppProxyContext | AppProxyContextWithSession>",
              "value": "Promise<AppProxyContext | AppProxyContextWithSession>"
            },
            "value": "export type AuthenticateAppProxy = (\n  request: Request,\n) => Promise<AppProxyContext | AppProxyContextWithSession>;"
          },
          "AppProxyContext": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "AppProxyContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "undefined",
                "description": "No session is available for the shop that made this request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice."
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "undefined",
                "description": "No session is available for the shop that made this request. Therefore no methods for interacting with the GraphQL / REST Admin APIs are available."
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "undefined",
                "description": "No session is available for the shop that made this request. Therefore no method for interacting with the Storefront API is available."
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "liquid",
                "value": "LiquidResponseFunction",
                "description": "A utility for creating a Liquid Response.",
                "examples": [
                  {
                    "title": "Rendering liquid content",
                    "description": "Use the `liquid` helper to render a `Response` with Liquid content using the shop's theme. See the [Liquid reference](https://shopify.dev/docs/api/liquid) for all the features it enables.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\"Hello {{shop.name}}\");\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering liquid content without a layout",
                    "description": "Set the `layout` option to `false` to render the Liquid content without a theme.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\n    \"Hello {{shop.name}}\",\n    { layout: false }\n  );\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering a form in a Liquid response",
                    "description": "Handle form submissions through an app proxy.",
                    "tabs": [
                      {
                        "code": "import { redirect } from \"@remix-run/node\";\nimport { authenticate } from \"~/shopify.server\";\n\nexport async function loader({ request }) {\n  const { liquid } = await authenticate.public.appProxy(request);\n\n  return liquid(`\n    <form method=\"post\" action=\"/apps/proxy/my-action\">\n      <input type=\"text\" name=\"field\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  `);\n}\n\nexport async function action({ request }) {\n  await authenticate.public.appProxy(request);\n\n  const formData = await request.formData();\n  const field = formData.get(\"field\")?.toString();\n\n  // Perform actions here\n  if (field) {\n    console.log(\"Field:\", field);\n  }\n\n  // Return to the form page\n  return redirect(\"/apps/proxy/my-action\");\n}",
                        "title": "app/routes/apps.proxy.my-action.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AppProxyContext extends Context {\n  /**\n   * No session is available for the shop that made this request.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   */\n  session: undefined;\n\n  /**\n   * No session is available for the shop that made this request.\n   * Therefore no methods for interacting with the GraphQL / REST Admin APIs are available.\n   */\n  admin: undefined;\n\n  /**\n   * No session is available for the shop that made this request.\n   * Therefore no method for interacting with the Storefront API is available.\n   */\n  storefront: undefined;\n}"
          },
          "LiquidResponseFunction": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "LiquidResponseFunction",
            "description": "",
            "params": [
              {
                "name": "body",
                "description": "",
                "value": "string",
                "filePath": "src/server/authenticate/public/appProxy/types.ts"
              },
              {
                "name": "initAndOptions",
                "description": "",
                "value": "number | (ResponseInit & Options)",
                "isOptional": true,
                "filePath": "src/server/authenticate/public/appProxy/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/public/appProxy/types.ts",
              "description": "",
              "name": "Response",
              "value": "Response"
            },
            "value": "export type LiquidResponseFunction = (\n  body: string,\n  initAndOptions?: number | (ResponseInit & Options),\n) => Response;"
          },
          "Options": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "Options",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "layout",
                "value": "boolean",
                "description": "Whether to use the shop's theme layout around the Liquid content.",
                "isOptional": true
              }
            ],
            "value": "interface Options {\n  /**\n   * Whether to use the shop's theme layout around the Liquid content.\n   */\n  layout?: boolean;\n}"
          },
          "AppProxyContextWithSession": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "AppProxyContextWithSession",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the shop that made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using the session object",
                    "description": "Get the session for the shop that initiated the request to the app proxy.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppModelData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }) => {\n  // Get the session for the shop that initiated the request to the app proxy.\n  const { session } =\n    await authenticate.public.appProxy(request);\n\n  // Use the session data to make to queries to your database or additional requests.\n  return json(\n    await getMyAppModelData({shop: session.shop})\n  );\n};",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request.",
                "examples": [
                  {
                    "title": "Interacting with the Admin API",
                    "description": "Use the `admin` object to interact with the REST or GraphQL APIs.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.public.appProxy(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" }\n      }\n    }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "StorefrontContext",
                "description": "Method for interacting with the Shopify Storefront Graphql API for the store that made the request.",
                "examples": [
                  {
                    "title": "Interacting with the Storefront API",
                    "description": "Use the `storefront` object to interact with the GraphQL API.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(\n    `#graphql\n    query blogIds {\n      blogs(first: 10) {\n        edges {\n          node {\n            id\n          }\n        }\n      }\n    }`\n  );\n\n  return json(await response.json());\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "liquid",
                "value": "LiquidResponseFunction",
                "description": "A utility for creating a Liquid Response.",
                "examples": [
                  {
                    "title": "Rendering liquid content",
                    "description": "Use the `liquid` helper to render a `Response` with Liquid content using the shop's theme. See the [Liquid reference](https://shopify.dev/docs/api/liquid) for all the features it enables.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\"Hello {{shop.name}}\");\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering liquid content without a layout",
                    "description": "Set the `layout` option to `false` to render the Liquid content without a theme.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\n    \"Hello {{shop.name}}\",\n    { layout: false }\n  );\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering a form in a Liquid response",
                    "description": "Handle form submissions through an app proxy.",
                    "tabs": [
                      {
                        "code": "import { redirect } from \"@remix-run/node\";\nimport { authenticate } from \"~/shopify.server\";\n\nexport async function loader({ request }) {\n  const { liquid } = await authenticate.public.appProxy(request);\n\n  return liquid(`\n    <form method=\"post\" action=\"/apps/proxy/my-action\">\n      <input type=\"text\" name=\"field\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  `);\n}\n\nexport async function action({ request }) {\n  await authenticate.public.appProxy(request);\n\n  const formData = await request.formData();\n  const field = formData.get(\"field\")?.toString();\n\n  // Perform actions here\n  if (field) {\n    console.log(\"Field:\", field);\n  }\n\n  // Return to the form page\n  return redirect(\"/apps/proxy/my-action\");\n}",
                        "title": "app/routes/apps.proxy.my-action.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AppProxyContextWithSession<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends Context {\n  /**\n   * The session for the shop that made the request.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   *\n   * Use this to get shop or user-specific data.\n   *\n   * @example\n   * <caption>Using the session object.</caption>\n   * <description>Get the session for the shop that initiated the request to the app proxy.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppModelData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }) => {\n   *   // Get the session for the shop that initiated the request to the app proxy.\n   *   const { session } =\n   *     await authenticate.public.appProxy(request);\n   *\n   *   // Use the session data to make to queries to your database or additional requests.\n   *   return json(\n   *     await getMyAppModelData({shop: session.shop})\n   *   );\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request.\n   *\n   * @example\n   * <caption>Interacting with the Admin API.</caption>\n   * <description>Use the `admin` object to interact with the REST or GraphQL APIs.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" }\n   *       }\n   *     }\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n\n  /**\n   * Method for interacting with the Shopify Storefront Graphql API for the store that made the request.\n   *\n   * @example\n   * <caption>Interacting with the Storefront API.</caption>\n   * <description>Use the `storefront` object to interact with the GraphQL API.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await storefront.graphql(\n   *     `#graphql\n   *     query blogIds {\n   *       blogs(first: 10) {\n   *         edges {\n   *           node {\n   *             id\n   *           }\n   *         }\n   *       }\n   *     }`\n   *   );\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  storefront: StorefrontContext;\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          },
          "StorefrontContext": {
            "filePath": "src/server/clients/storefront/types.ts",
            "name": "StorefrontContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<StorefrontOperations>",
                "description": "Method for interacting with the Shopify Storefront GraphQL API\n\nIf you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `storefront.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  try {\n    const response = await storefront.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // { errors: { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] } }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface StorefrontContext {\n  /**\n   * Method for interacting with the Shopify Storefront GraphQL API\n   *\n   * If you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n   *\n   * {@link https://shopify.dev/docs/api/storefront}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `storefront.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   try {\n   *     const response = await storefront.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // { errors: { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] } }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<StorefrontOperations>;\n}"
          }
        }
      }
    ],
    "defaultExample": {
      "description": "Authenticate and fetch product information",
      "codeblock": {
        "title": "Authenticate and fetch product information",
        "tabs": [
          {
            "title": "/app/routes/**.ts",
            "language": "typescript",
            "code": "import type {LoaderFunctionArgs} from '@remix-run/node';\n\nimport {authenticate} from '../shopify.server';\n\nexport const loader = async ({request}: LoaderFunctionArgs) =&gt; {\n  const {storefront, liquid} = await authenticate.public.appProxy(request);\n\n  if (!storefront) {\n    return new Response();\n  }\n\n  const response = await storefront.graphql(\n    `#graphql\n    query productTitle {\n      products(first: 1) {\n        nodes {\n          title\n        }\n      }\n    }`,\n  );\n  const body = await response.json();\n\n  const title = body.data.products.nodes[0].title;\n\n  return liquid(`Found product ${title} from {{shop.name}}`);\n};\n"
          }
        ]
      }
    },
    "jsDocTypeExamples": [
      "AppProxyContextWithSession"
    ],
    "related": [
      {
        "name": "Admin API context",
        "subtitle": "Interact with the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/admin-api"
      },
      {
        "name": "Storefront API context",
        "subtitle": "Interact with the Storefront API.",
        "url": "/docs/api/shopify-app-remix/apis/storefront-api"
      },
      {
        "name": "Liquid reference",
        "subtitle": "Use the shop's theme to render a template.",
        "url": "/docs/api/liquid",
        "type": "liquid"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "session",
          "examples": [
            {
              "description": "Get the session for the shop that initiated the request to the app proxy.",
              "codeblock": {
                "title": "Using the session object",
                "tabs": [
                  {
                    "title": "app/routes/**\\/.ts",
                    "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppModelData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }) =&gt; {\n  // Get the session for the shop that initiated the request to the app proxy.\n  const { session } =\n    await authenticate.public.appProxy(request);\n\n  // Use the session data to make to queries to your database or additional requests.\n  return json(\n    await getMyAppModelData({shop: session.shop})\n  );\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "admin",
          "examples": [
            {
              "description": "Use the `admin` object to interact with the REST or GraphQL APIs.",
              "codeblock": {
                "title": "Interacting with the Admin API",
                "tabs": [
                  {
                    "title": "app/routes/**\\/.ts",
                    "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.public.appProxy(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" }\n      }\n    }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "storefront",
          "examples": [
            {
              "description": "Use the `storefront` object to interact with the GraphQL API.",
              "codeblock": {
                "title": "Interacting with the Storefront API",
                "tabs": [
                  {
                    "title": "app/routes/**\\/.ts",
                    "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(\n    `#graphql\n    query blogIds {\n      blogs(first: 10) {\n        edges {\n          node {\n            id\n          }\n        }\n      }\n    }`\n  );\n\n  return json(await response.json());\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "liquid",
          "examples": [
            {
              "description": "Use the `liquid` helper to render a `Response` with Liquid content using the shop's theme. See the [Liquid reference](https://shopify.dev/docs/api/liquid) for all the features it enables.",
              "codeblock": {
                "title": "Rendering liquid content",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\"Hello {{shop.name}}\");\n}",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Set the `layout` option to `false` to render the Liquid content without a theme.",
              "codeblock": {
                "title": "Rendering liquid content without a layout",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\n    \"Hello {{shop.name}}\",\n    { layout: false }\n  );\n}",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Handle form submissions through an app proxy.",
              "codeblock": {
                "title": "Rendering a form in a Liquid response",
                "tabs": [
                  {
                    "title": "app/routes/apps.proxy.my-action.tsx",
                    "code": "import { redirect } from \"@remix-run/node\";\nimport { authenticate } from \"~/shopify.server\";\n\nexport async function loader({ request }) {\n  const { liquid } = await authenticate.public.appProxy(request);\n\n  return liquid(`\n    &lt;form method=\"post\" action=\"/apps/proxy/my-action\"&gt;\n      &lt;input type=\"text\" name=\"field\" /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  `);\n}\n\nexport async function action({ request }) {\n  await authenticate.public.appProxy(request);\n\n  const formData = await request.formData();\n  const field = formData.get(\"field\")?.toString();\n\n  // Perform actions here\n  if (field) {\n    console.log(\"Field:\", field);\n  }\n\n  // Return to the form page\n  return redirect(\"/apps/proxy/my-action\");\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Checkout",
    "description": "The `authenticate.public.checkout` function ensures that checkout extension requests are coming from Shopify, and returns helpers to respond with the correct headers.",
    "category": "Authenticate",
    "subCategory": "Public",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "authenticate.public.checkout",
        "description": "Authenticates requests coming from Shopify checkout extensions.",
        "type": "AuthenticateCheckout",
        "typeDefinitions": {
          "AuthenticateCheckout": {
            "filePath": "src/server/authenticate/public/checkout/types.ts",
            "name": "AuthenticateCheckout",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/public/checkout/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "AuthenticateCheckoutOptions",
                "isOptional": true,
                "filePath": "src/server/authenticate/public/checkout/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/public/checkout/types.ts",
              "description": "",
              "name": "Promise<CheckoutContext>",
              "value": "Promise<CheckoutContext>"
            },
            "value": "export type AuthenticateCheckout = (\n  request: Request,\n  options?: AuthenticateCheckoutOptions,\n) => Promise<CheckoutContext>;"
          },
          "AuthenticateCheckoutOptions": {
            "filePath": "src/server/authenticate/public/checkout/types.ts",
            "name": "AuthenticateCheckoutOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/checkout/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "corsHeaders",
                "value": "string[]",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface AuthenticateCheckoutOptions {\n  corsHeaders?: string[];\n}"
          },
          "CheckoutContext": {
            "filePath": "src/server/authenticate/public/checkout/types.ts",
            "name": "CheckoutContext",
            "description": "Authenticated Context for a checkout request",
            "members": [
              {
                "filePath": "src/server/authenticate/public/checkout/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionToken",
                "value": "JwtPayload",
                "description": "The decoded and validated session token for the request\n\nRefer to the OAuth docs for the [session token payload](https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload).",
                "examples": [
                  {
                    "title": "Using the decoded session token",
                    "description": "Get store-specific data using the `sessionToken` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken } = await authenticate.public.checkout(\n    request\n  );\n  return json(await getMyAppData({shop: sessionToken.dest}));\n};",
                        "title": "app/routes/public/my-route.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/checkout/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a public request",
                    "description": "Use the `cors` helper to ensure your app can respond to checkout extension requests.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken, cors } = await authenticate.public.checkout(\n    request,\n    { corsHeaders: [\"X-My-Custom-Header\"] }\n  );\n  const data = await getMyAppData({shop: sessionToken.dest});\n  return cors(json(data));\n};",
                        "title": "app/routes/public/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface CheckoutContext {\n  /**\n   * The decoded and validated session token for the request\n   *\n   * Refer to the OAuth docs for the [session token payload](https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload).\n   *\n   * @example\n   * <caption>Using the decoded session token.</caption>\n   * <description>Get store-specific data using the `sessionToken` object.</description>\n   * ```ts\n   * // app/routes/public/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken } = await authenticate.public.checkout(\n   *     request\n   *   );\n   *   return json(await getMyAppData({shop: sessionToken.dest}));\n   * };\n   * ```\n   */\n  sessionToken: JwtPayload;\n\n  /**\n   * A function that ensures the CORS headers are set correctly for the response.\n   *\n   * @example\n   * <caption>Setting CORS headers for a public request.</caption>\n   * <description>Use the `cors` helper to ensure your app can respond to checkout extension requests.</description>\n   * ```ts\n   * // app/routes/public/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken, cors } = await authenticate.public.checkout(\n   *     request,\n   *     { corsHeaders: [\"X-My-Custom-Header\"] }\n   *   );\n   *   const data = await getMyAppData({shop: sessionToken.dest});\n   *   return cors(json(data));\n   * };\n   * ```\n   */\n  cors: EnsureCORSFunction;\n}"
          },
          "JwtPayload": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "JwtPayload",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iss",
                "value": "string",
                "description": "The shop's admin domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "dest",
                "value": "string",
                "description": "The shop's domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "aud",
                "value": "string",
                "description": "The client ID of the receiving app."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sub",
                "value": "string",
                "description": "The User that the session token is intended for."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "exp",
                "value": "number",
                "description": "When the session token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nbf",
                "value": "number",
                "description": "When the session token activates."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iat",
                "value": "number",
                "description": "When the session token was issued."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "jti",
                "value": "string",
                "description": "A secure random UUID."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sid",
                "value": "string",
                "description": "A unique session ID per user and app."
              }
            ],
            "value": "export interface JwtPayload {\n  /**\n   * The shop's admin domain.\n   */\n  iss: string;\n  /**\n   * The shop's domain.\n   */\n  dest: string;\n  /**\n   * The client ID of the receiving app.\n   */\n  aud: string;\n  /**\n   * The User that the session token is intended for.\n   */\n  sub: string;\n  /**\n   * When the session token expires.\n   */\n  exp: number;\n  /**\n   * When the session token activates.\n   */\n  nbf: number;\n  /**\n   * When the session token was issued.\n   */\n  iat: number;\n  /**\n   * A secure random UUID.\n   */\n  jti: string;\n  /**\n   * A unique session ID per user and app.\n   */\n  sid: string;\n}"
          },
          "EnsureCORSFunction": {
            "filePath": "src/server/authenticate/helpers/ensure-cors-headers.ts",
            "name": "EnsureCORSFunction",
            "description": "",
            "members": [],
            "value": "export interface EnsureCORSFunction {\n  (response: Response): Response;\n}"
          }
        }
      }
    ],
    "defaultExample": {
      "description": "Authenticate and return offers for the shop",
      "codeblock": {
        "title": "Authenticate and return offers for the shop",
        "tabs": [
          {
            "title": "/app/routes/**.ts",
            "language": "typescript",
            "code": "import type {ActionFunctionArgs, LoaderFunctionArgs} from '@remix-run/node';\nimport {json} from '@remix-run/node';\n\nimport {authenticate} from '../shopify.server';\nimport {getOffers} from '../offers.server';\n\n// The loader responds to preflight requests from Shopify\nexport const loader = async ({request}: LoaderFunctionArgs) =&gt; {\n  await authenticate.public.checkout(request);\n};\n\nexport const action = async ({request}: ActionFunctionArgs) =&gt; {\n  const {cors, sessionToken} = await authenticate.public.checkout(request);\n\n  const offers = getOffers(sessionToken.dest);\n  return cors(json({offers}));\n};\n"
          },
          {
            "title": "/app/offers.server.ts",
            "language": "typescript",
            "code": "// Most apps would load this from their database\nexport function getOffers(shop: string) {\n  const offers: Record&lt;any, any[]&gt; = {\n    'shop.com': [\n      {\n        id: '1',\n        title: '10% off',\n        price: 10,\n        type: 'percentage',\n      },\n      {\n        id: '2',\n        title: 'Free shipping',\n        price: 0,\n        type: 'shipping',\n      },\n    ],\n  };\n\n  return offers[shop];\n}\n"
          }
        ]
      }
    },
    "jsDocTypeExamples": [
      "CheckoutContext"
    ],
    "related": [],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "sessionToken",
          "examples": [
            {
              "description": "Get store-specific data using the `sessionToken` object.",
              "codeblock": {
                "title": "Using the decoded session token",
                "tabs": [
                  {
                    "title": "app/routes/public/my-route.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { sessionToken } = await authenticate.public.checkout(\n    request\n  );\n  return json(await getMyAppData({shop: sessionToken.dest}));\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "cors",
          "examples": [
            {
              "description": "Use the `cors` helper to ensure your app can respond to checkout extension requests.",
              "codeblock": {
                "title": "Setting CORS headers for a public request",
                "tabs": [
                  {
                    "title": "app/routes/public/my-route.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const { sessionToken, cors } = await authenticate.public.checkout(\n    request,\n    { corsHeaders: [\"X-My-Custom-Header\"] }\n  );\n  const data = await getMyAppData({shop: sessionToken.dest});\n  return cors(json(data));\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Webhook",
    "description": "Contains functions for verifying Shopify webhooks.\n\n> Note: The format of the `admin` object returned by this function changes with the `v3_webhookAdminContext` future flag. Learn more about [gradual feature adoption](/docs/api/shopify-app-remix/guide-future-flags).",
    "category": "Authenticate",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "authenticate.webhook",
        "description": "Verifies requests coming from Shopify webhooks.",
        "type": "AuthenticateWebhook",
        "typeDefinitions": {
          "AuthenticateWebhook": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "AuthenticateWebhook",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/webhooks/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/webhooks/types.ts",
              "description": "",
              "name": "Promise<WebhookContext<Future, Resources, Topics>>",
              "value": "Promise<WebhookContext<Future, Resources, Topics>>"
            },
            "value": "export type AuthenticateWebhook<\n  Future extends FutureFlagOptions,\n  Resources extends ShopifyRestResources,\n  Topics = string | number | symbol,\n> = (request: Request) => Promise<WebhookContext<Future, Resources, Topics>>;"
          },
          "WebhookContext": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "WebhookContext",
            "value": "WebhookContextWithoutSession<Topics> | WebhookContextWithSession<Future, Resources, Topics>",
            "description": ""
          },
          "WebhookContextWithoutSession": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "WebhookContextWithoutSession",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "undefined",
                "description": ""
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "undefined",
                "description": ""
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "string",
                "description": "The API version used for the webhook.",
                "examples": [
                  {
                    "title": "Webhook API version",
                    "description": "Get the API version used for webhook request.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { apiVersion } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The shop where the webhook was triggered.",
                "examples": [
                  {
                    "title": "Webhook shop",
                    "description": "Get the shop that triggered a webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { shop } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "topic",
                "value": "Topics",
                "description": "The topic of the webhook.",
                "examples": [
                  {
                    "title": "Webhook topic",
                    "description": "Get the event topic for the webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { topic } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      // Do something when the app is uninstalled.\n      break;\n  }\n\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "webhookId",
                "value": "string",
                "description": "A unique ID for the webhook. Useful to keep track of which events your app has already processed.",
                "examples": [
                  {
                    "title": "Webhook ID",
                    "description": "Get the webhook ID.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { webhookId } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "Record<string, any>",
                "description": "The payload from the webhook request.",
                "examples": [
                  {
                    "title": "Webhook payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { payload } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subTopic",
                "value": "string",
                "description": "The sub-topic of the webhook. This is only available for certain webhooks.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Webhook sub-topic",
                    "description": "Get the webhook sub-topic.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { subTopic } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface WebhookContextWithoutSession<Topics = string | number | symbol>\n  extends Context<Topics> {\n  session: undefined;\n  admin: undefined;\n}"
          },
          "WebhookContextWithSession": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "WebhookContextWithSession",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "A session with an offline token for the shop.\n\nReturned only if there is a session for the shop."
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "WebhookAdminContext<Future, Resources>",
                "description": "An admin context for the webhook.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "[V3] Webhook admin context",
                    "description": "With the `v3_webhookAdminContext` future flag enabled, use the `admin` object in the context to interact with the Admin API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.webhook(request);\n\n  const response = await admin?.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  },
                  {
                    "title": "Webhook admin context",
                    "description": "Use the `admin` object in the context to interact with the Admin API. This format will be removed in V3 of the package.",
                    "tabs": [
                      {
                        "code": "import { json, ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.webhook(request);\n\n  const response = await admin?.graphql.query<any>({\n    data: {\n      query: `#graphql\n        mutation populateProduct($input: ProductInput!) {\n          productCreate(input: $input) {\n            product {\n              id\n            }\n          }\n        }`,\n      variables: { input: { title: \"Product Name\" } },\n    },\n  });\n\n  const productData = response?.body.data;\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "string",
                "description": "The API version used for the webhook.",
                "examples": [
                  {
                    "title": "Webhook API version",
                    "description": "Get the API version used for webhook request.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { apiVersion } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The shop where the webhook was triggered.",
                "examples": [
                  {
                    "title": "Webhook shop",
                    "description": "Get the shop that triggered a webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { shop } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "topic",
                "value": "Topics",
                "description": "The topic of the webhook.",
                "examples": [
                  {
                    "title": "Webhook topic",
                    "description": "Get the event topic for the webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { topic } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      // Do something when the app is uninstalled.\n      break;\n  }\n\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "webhookId",
                "value": "string",
                "description": "A unique ID for the webhook. Useful to keep track of which events your app has already processed.",
                "examples": [
                  {
                    "title": "Webhook ID",
                    "description": "Get the webhook ID.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { webhookId } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "Record<string, any>",
                "description": "The payload from the webhook request.",
                "examples": [
                  {
                    "title": "Webhook payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { payload } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subTopic",
                "value": "string",
                "description": "The sub-topic of the webhook. This is only available for certain webhooks.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Webhook sub-topic",
                    "description": "Get the webhook sub-topic.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { subTopic } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface WebhookContextWithSession<\n  Future extends FutureFlagOptions,\n  Resources extends ShopifyRestResources,\n  Topics = string | number | symbol,\n> extends Context<Topics> {\n  /**\n   * A session with an offline token for the shop.\n   *\n   * Returned only if there is a session for the shop.\n   */\n  session: Session;\n\n  /**\n   * An admin context for the webhook.\n   *\n   * Returned only if there is a session for the shop.\n   *\n   * @example\n   * <caption>[V3] Webhook admin context.</caption>\n   * <description>With the `v3_webhookAdminContext` future flag enabled, use the `admin` object in the context to interact with the Admin API.</description>\n   * ```ts\n   * // /app/routes/webhooks.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.webhook(request);\n   *\n   *   const response = await admin?.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     { variables: { input: { title: \"Product Name\" } } }\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Webhook admin context.</caption>\n   * <description>Use the `admin` object in the context to interact with the Admin API. This format will be removed in V3 of the package.</description>\n   * ```ts\n   * // /app/routes/webhooks.tsx\n   * import { json, ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.webhook(request);\n   *\n   *   const response = await admin?.graphql.query<any>({\n   *     data: {\n   *       query: `#graphql\n   *         mutation populateProduct($input: ProductInput!) {\n   *           productCreate(input: $input) {\n   *             product {\n   *               id\n   *             }\n   *           }\n   *         }`,\n   *       variables: { input: { title: \"Product Name\" } },\n   *     },\n   *   });\n   *\n   *   const productData = response?.body.data;\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   */\n  admin: WebhookAdminContext<Future, Resources>;\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "WebhookAdminContext": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "WebhookAdminContext",
            "value": "FeatureEnabled<Future, 'v3_webhookAdminContext'> extends true\n    ? AdminApiContext<Resources>\n    : LegacyWebhookAdminApiContext<Resources>",
            "description": ""
          },
          "AdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AdminContext",
            "value": "Config['isEmbeddedApp'] extends false\n  ? NonEmbeddedAdminContext<Config, Resources>\n  : EmbeddedAdminContext<Config, Resources>",
            "description": ""
          },
          "NonEmbeddedAdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "NonEmbeddedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the user who made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using offline sessions",
                    "description": "Get your app's shop-specific data using an offline session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Using online sessions",
                    "description": "Get your app's user-specific data using an online session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request."
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingContext<Config>",
                "description": "Billing methods for this store, based on the plans defined in the `billing` config option.\n\n\n\n\n"
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a admin request",
                    "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface NonEmbeddedAdminContext<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends AdminContextInternal<Config, Resources> {}"
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          },
          "BillingContext": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "BillingContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "require",
                "value": "(options: RequireBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Requesting billing right away",
                    "description": "Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirect to a plan selection page",
                    "description": "When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n    isTest: true,\n    onFailure: () => redirect('/select-plan'),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Requesting billing with line items",
                    "description": "Call `billing.request` with the `v3_lineItemBilling` future flag enabled",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      lineItems: [\n       {\n         amount: 5,\n         currencyCode: 'USD',\n         interval: BillingInterval.Every30Days,\n        },\n        {\n         amount: 1,\n         currencyCode: 'USD',\n         interval: BillingInterval.Usage.\n         terms: '1 dollar per 1000 emails',\n        },\n      ],\n    },\n  }\n future: {v3_lineItemBilling: true}\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "check",
                "value": "(options: CheckBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Check what billing plans a merchant is subscribed to",
                    "description": "Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does notthrow an error if no active billing plans are present.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const { hasActivePayment, appSubscriptions } = await billing.check({\n    plans: [MONTHLY_PLAN],\n    isTest: false,\n  });\n console.log(hasActivePayment)\n console.log(appSubscriptions)\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "(options: RequestBillingOptions<Config>) => Promise<never>",
                "description": "Requests payment for the plan.",
                "examples": [
                  {
                    "title": "Using a custom return URL",
                    "description": "Change where the merchant is returned to after approving the purchase using the `returnUrl` option.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({\n      plan: MONTHLY_PLAN,\n      isTest: true,\n      returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n    }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cancel",
                "value": "(options: CancelBillingOptions) => Promise<AppSubscription>",
                "description": "Cancels an ongoing subscription, given its ID.",
                "examples": [
                  {
                    "title": "Cancelling a subscription",
                    "description": "Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  const cancelledSubscription = await billing.cancel({\n    subscriptionId: subscription.id,\n    isTest: true,\n    prorate: true,\n   });\n\n  // App logic\n};",
                        "title": "/app/routes/cancel-subscription.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface BillingContext<Config extends AppConfigArg> {\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Requesting billing right away.</caption>\n   * <description>Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Redirect to a plan selection page.</caption>\n   * <description> When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n   *     isTest: true,\n   *     onFailure: () => redirect('/select-plan'),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   * @example\n   * <caption>Requesting billing with line items</caption>\n   * <description>Call `billing.request` with the `v3_lineItemBilling` future flag enabled</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       lineItems: [\n   *        {\n   *          amount: 5,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Every30Days,\n   *         },\n   *         {\n   *          amount: 1,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Usage.\n   *          terms: '1 dollar per 1000 emails',\n   *         },\n   *       ],\n   *     },\n   *   }\n   *  future: {v3_lineItemBilling: true}\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  require: (\n    options: RequireBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Check what billing plans a merchant is subscribed to.</caption>\n   * <description>Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does not\n   * throw an error if no active billing plans are present. </description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const { hasActivePayment, appSubscriptions } = await billing.check({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: false,\n   *   });\n   *  console.log(hasActivePayment)\n   *  console.log(appSubscriptions)\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   */\n  check: (\n    options: CheckBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Requests payment for the plan.\n   *\n   * @returns Redirects to the confirmation URL for the payment.\n   *\n   * @example\n   * <caption>Using a custom return URL.</caption>\n   * <description>Change where the merchant is returned to after approving the purchase using the `returnUrl` option.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({\n   *       plan: MONTHLY_PLAN,\n   *       isTest: true,\n   *       returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n   *     }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  request: (options: RequestBillingOptions<Config>) => Promise<never>;\n\n  /**\n   * Cancels an ongoing subscription, given its ID.\n   *\n   * @returns The cancelled subscription.\n   *\n   * @example\n   * <caption>Cancelling a subscription.</caption>\n   * <description>Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.</description>\n   * ```ts\n   * // /app/routes/cancel-subscription.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   const cancelledSubscription = await billing.cancel({\n   *     subscriptionId: subscription.id,\n   *     isTest: true,\n   *     prorate: true,\n   *    });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  cancel: (options: CancelBillingOptions) => Promise<AppSubscription>;\n}"
          },
          "RequireBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequireBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onFailure",
                "value": "(error: any) => Promise<Response>",
                "description": "How to handle the request if the shop doesn't have an active payment for any plan."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface RequireBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n  /**\n   * How to handle the request if the shop doesn't have an active payment for any plan.\n   */\n  onFailure: (error: any) => Promise<Response>;\n}"
          },
          "BillingCheckResponseObject": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingCheckResponseObject",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hasActivePayment",
                "value": "boolean",
                "description": "Whether the user has an active payment method."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "oneTimePurchases",
                "value": "OneTimePurchase[]",
                "description": "The one-time purchases the shop has."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "appSubscriptions",
                "value": "AppSubscription[]",
                "description": "The active subscriptions the shop has."
              }
            ],
            "value": "export interface BillingCheckResponseObject {\n  /**\n   * Whether the user has an active payment method.\n   */\n  hasActivePayment: boolean;\n  /**\n   * The one-time purchases the shop has.\n   */\n  oneTimePurchases: OneTimePurchase[];\n  /**\n   * The active subscriptions the shop has.\n   */\n  appSubscriptions: AppSubscription[];\n}"
          },
          "OneTimePurchase": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "OneTimePurchase",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the one-time purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "status",
                "value": "string",
                "description": "The status of the one-time purchase."
              }
            ],
            "value": "export interface OneTimePurchase {\n  /**\n   * The ID of the one-time purchase.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  test: boolean;\n  /**\n   * The status of the one-time purchase.\n   */\n  status: string;\n}"
          },
          "AppSubscription": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppSubscription",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the app subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "lineItems",
                "value": "ActiveSubscriptionLineItem[]",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface AppSubscription {\n  /**\n   * The ID of the app subscription.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test subscription.\n   */\n  test: boolean;\n\n  /*\n   * The line items for this plan. This will become mandatory in v10.\n   */\n  lineItems?: ActiveSubscriptionLineItem[];\n}"
          },
          "ActiveSubscriptionLineItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "ActiveSubscriptionLineItem",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "AppPlan",
                "description": ""
              }
            ],
            "value": "export interface ActiveSubscriptionLineItem {\n  /*\n   * The ID of the line item.\n   */\n  id: string;\n  /*\n   * The details of the plan.\n   */\n  plan: AppPlan;\n}"
          },
          "AppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pricingDetails",
                "value": "RecurringAppPlan | UsageAppPlan",
                "description": ""
              }
            ],
            "value": "export interface AppPlan {\n  /*\n   * The pricing details of the plan.\n   */\n  pricingDetails: RecurringAppPlan | UsageAppPlan;\n}"
          },
          "RecurringAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "RecurringAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Every30Days | BillingInterval.Annual",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "discount",
                "value": "AppPlanDiscount",
                "description": ""
              }
            ],
            "value": "export interface RecurringAppPlan {\n  /*\n   * The interval for this plan is charged on.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /*\n   * The price of the plan.\n   */\n  price: Money;\n  /*\n   * The discount applied to the plan.\n   */\n  discount: AppPlanDiscount;\n}"
          },
          "BillingInterval": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "BillingInterval",
            "value": "export enum BillingInterval {\n  OneTime = 'ONE_TIME',\n  Every30Days = 'EVERY_30_DAYS',\n  Annual = 'ANNUAL',\n  Usage = 'USAGE',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "OneTime",
                "value": "ONE_TIME"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Every30Days",
                "value": "EVERY_30_DAYS"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Annual",
                "value": "ANNUAL"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Usage",
                "value": "USAGE"
              }
            ]
          },
          "Money": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "Money",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": ""
              }
            ],
            "value": "interface Money {\n  amount: number;\n  currencyCode: string;\n}"
          },
          "AppPlanDiscount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlanDiscount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "durationLimitInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "remainingDurationInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "priceAfterDiscount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "AppPlanDiscountAmount",
                "description": ""
              }
            ],
            "value": "export interface AppPlanDiscount {\n  /*\n   * The total number of intervals the discount applies to.\n   */\n  durationLimitInIntervals: number;\n  /*\n   * The remaining number of intervals the discount applies to.\n   */\n  remainingDurationInIntervals: number;\n  /*\n   * The price after the discount is applied.\n   */\n  priceAfterDiscount: Money;\n  /*\n   * The value of the discount applied every billing interval.\n   */\n  value: AppPlanDiscountAmount;\n}"
          },
          "AppPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AppPlanDiscountAmount",
            "value": "BillingConfigSubscriptionPlanDiscountAmount | BillingConfigSubscriptionPlanDiscountPercentage",
            "description": ""
          },
          "BillingConfigSubscriptionPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountAmount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "never",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set.",
                "isOptional": true
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountAmount {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount: number;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage?: never;\n}"
          },
          "BillingConfigSubscriptionPlanDiscountPercentage": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountPercentage",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "never",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "number",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set."
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountPercentage {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount?: never;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage: number;\n}"
          },
          "UsageAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "UsageAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "balanceUsed",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cappedAmount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "terms",
                "value": "string",
                "description": ""
              }
            ],
            "value": "export interface UsageAppPlan {\n  /*\n   * The total usage records for interval.\n   */\n  balanceUsed: Money;\n  /*\n   * The capped amount prevents the merchant from being charged for any usage over that amount during a billing period.\n   */\n  cappedAmount: Money;\n  /*\n   * The terms and conditions for app usage pricing.\n   */\n  terms: string;\n}"
          },
          "CheckBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CheckBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface CheckBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n}"
          },
          "RequestBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequestBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "keyof Config[\"billing\"]",
                "description": "The plan to request. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "returnUrl",
                "value": "string",
                "description": "The URL to return to after the merchant approves the payment.",
                "isOptional": true
              }
            ],
            "value": "export interface RequestBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingRequestParams, 'session' | 'plan' | 'returnObject'> {\n  /**\n   * The plan to request. Must be one of the values defined in the `billing` config option.\n   */\n  plan: keyof Config['billing'];\n  /**\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n  /**\n   * The URL to return to after the merchant approves the payment.\n   */\n  returnUrl?: string;\n}"
          },
          "CancelBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CancelBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subscriptionId",
                "value": "string",
                "description": "The ID of the subscription to cancel."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "prorate",
                "value": "boolean",
                "description": "Whether to prorate the cancellation.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface CancelBillingOptions {\n  /**\n   * The ID of the subscription to cancel.\n   */\n  subscriptionId: string;\n  /**\n   * Whether to prorate the cancellation.\n   *\n   * {@link https://shopify.dev/docs/apps/billing/subscriptions/cancel-recurring-charges}\n   */\n  prorate?: boolean;\n  /*\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n}"
          },
          "EnsureCORSFunction": {
            "filePath": "src/server/authenticate/helpers/ensure-cors-headers.ts",
            "name": "EnsureCORSFunction",
            "description": "",
            "members": [],
            "value": "export interface EnsureCORSFunction {\n  (response: Response): Response;\n}"
          },
          "EmbeddedAdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "EmbeddedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionToken",
                "value": "JwtPayload",
                "description": "The decoded and validated session token for the request.\n\nReturned only if `isEmbeddedApp` is `true`.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using the decoded session token",
                    "description": "Get user-specific data using the `sessionToken` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken } = await authenticate.admin(\n    request\n  );\n  return json(await getMyAppData({user: sessionToken.sub}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "redirect",
                "value": "RedirectFunction",
                "description": "A function that redirects the user to a new page, ensuring that the appropriate parameters are set for embedded apps.\n\nReturned only if `isEmbeddedApp` is `true`.",
                "examples": [
                  {
                    "title": "Redirecting to an app route",
                    "description": "Use the `redirect` helper to safely redirect between pages.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\");\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirecting outside of Shopify admin",
                    "description": "Pass in a `target` option of `_top` or `_parent` to go to an external URL.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\", { target: '_parent' });\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the user who made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using offline sessions",
                    "description": "Get your app's shop-specific data using an offline session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Using online sessions",
                    "description": "Get your app's user-specific data using an online session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request."
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingContext<Config>",
                "description": "Billing methods for this store, based on the plans defined in the `billing` config option.\n\n\n\n\n"
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a admin request",
                    "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface EmbeddedAdminContext<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends AdminContextInternal<Config, Resources> {\n  /**\n   * The decoded and validated session token for the request.\n   *\n   * Returned only if `isEmbeddedApp` is `true`.\n   *\n   * {@link https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload}\n   *\n   * @example\n   * <caption>Using the decoded session token.</caption>\n   * <description>Get user-specific data using the `sessionToken` object.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken } = await authenticate.admin(\n   *     request\n   *   );\n   *   return json(await getMyAppData({user: sessionToken.sub}));\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   useOnlineTokens: true,\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  sessionToken: JwtPayload;\n\n  /**\n   * A function that redirects the user to a new page, ensuring that the appropriate parameters are set for embedded\n   * apps.\n   *\n   * Returned only if `isEmbeddedApp` is `true`.\n   *\n   * @example\n   * <caption>Redirecting to an app route.</caption>\n   * <description>Use the `redirect` helper to safely redirect between pages.</description>\n   * ```ts\n   * // /app/routes/admin/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { session, redirect } = await authenticate.admin(request);\n   *   return redirect(\"/\");\n   * };\n   * ```\n   *\n   * @example\n   * <caption>Redirecting outside of Shopify admin.</caption>\n   * <description>Pass in a `target` option of `_top` or `_parent` to go to an external URL.</description>\n   * ```ts\n   * // /app/routes/admin/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { session, redirect } = await authenticate.admin(request);\n   *   return redirect(\"/\", { target: '_parent' });\n   * };\n   * ```\n   */\n  redirect: RedirectFunction;\n}"
          },
          "JwtPayload": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "JwtPayload",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iss",
                "value": "string",
                "description": "The shop's admin domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "dest",
                "value": "string",
                "description": "The shop's domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "aud",
                "value": "string",
                "description": "The client ID of the receiving app."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sub",
                "value": "string",
                "description": "The User that the session token is intended for."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "exp",
                "value": "number",
                "description": "When the session token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nbf",
                "value": "number",
                "description": "When the session token activates."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iat",
                "value": "number",
                "description": "When the session token was issued."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "jti",
                "value": "string",
                "description": "A secure random UUID."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sid",
                "value": "string",
                "description": "A unique session ID per user and app."
              }
            ],
            "value": "export interface JwtPayload {\n  /**\n   * The shop's admin domain.\n   */\n  iss: string;\n  /**\n   * The shop's domain.\n   */\n  dest: string;\n  /**\n   * The client ID of the receiving app.\n   */\n  aud: string;\n  /**\n   * The User that the session token is intended for.\n   */\n  sub: string;\n  /**\n   * When the session token expires.\n   */\n  exp: number;\n  /**\n   * When the session token activates.\n   */\n  nbf: number;\n  /**\n   * When the session token was issued.\n   */\n  iat: number;\n  /**\n   * A secure random UUID.\n   */\n  jti: string;\n  /**\n   * A unique session ID per user and app.\n   */\n  sid: string;\n}"
          },
          "RedirectFunction": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "name": "RedirectFunction",
            "description": "",
            "params": [
              {
                "name": "url",
                "description": "",
                "value": "string",
                "filePath": "src/server/authenticate/admin/helpers/redirect.ts"
              },
              {
                "name": "init",
                "description": "",
                "value": "RedirectInit",
                "isOptional": true,
                "filePath": "src/server/authenticate/admin/helpers/redirect.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
              "description": "",
              "name": "TypedResponse<never>",
              "value": "TypedResponse<never>"
            },
            "value": "export type RedirectFunction = (\n  url: string,\n  init?: RedirectInit,\n) => TypedResponse<never>;"
          },
          "RedirectInit": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RedirectInit",
            "value": "number | (ResponseInit & {target?: RedirectTarget})",
            "description": ""
          },
          "RedirectTarget": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RedirectTarget",
            "value": "'_self' | '_parent' | '_top'",
            "description": ""
          },
          "LegacyWebhookAdminApiContext": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "LegacyWebhookAdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClient & Resources",
                "description": "A REST client."
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "InstanceType<Shopify['clients']['Graphql']>",
                "description": "A GraphQL client."
              }
            ],
            "value": "export interface LegacyWebhookAdminApiContext<\n  Resources extends ShopifyRestResources,\n> {\n  /** A REST client. */\n  rest: InstanceType<Shopify['clients']['Rest']> & Resources;\n  /** A GraphQL client. */\n  graphql: InstanceType<Shopify['clients']['Graphql']>;\n}"
          },
          "RestClient": {
            "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
            "name": "RestClient",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "loggedDeprecations",
                "value": "Record<string, number>",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "client",
                "value": "AdminRestApiClient",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "<T = any>(params: GetRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "<T = any>(params: PostRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "<T = any>(params: PostRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "<T = any>(params: GetRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "export class RestClient {\n  public static config: ConfigInterface;\n  public static formatPaths: boolean;\n\n  static LINK_HEADER_REGEXP = /<([^<]+)>; rel=\"([^\"]+)\"/;\n  static DEFAULT_LIMIT = '50';\n  static RETRY_WAIT_TIME = 1000;\n\n  static readonly DEPRECATION_ALERT_DELAY = 300000;\n  loggedDeprecations: Record<string, number> = {};\n\n  readonly client: AdminRestApiClient;\n  readonly session: Session;\n  readonly apiVersion: ApiVersion;\n\n  public constructor({session, apiVersion}: RestClientParams) {\n    const config = this.restClass().config;\n\n    if (!config.isCustomStoreApp && !session.accessToken) {\n      throw new ShopifyErrors.MissingRequiredArgument(\n        'Missing access token when creating REST client',\n      );\n    }\n\n    if (apiVersion) {\n      const message =\n        apiVersion === config.apiVersion\n          ? `REST client has a redundant API version override to the default ${apiVersion}`\n          : `REST client overriding default API version ${config.apiVersion} with ${apiVersion}`;\n\n      logger(config).debug(message);\n    }\n\n    const customStoreAppAccessToken =\n      config.adminApiAccessToken ?? config.apiSecretKey;\n\n    this.session = session;\n    this.apiVersion = apiVersion ?? config.apiVersion;\n    this.client = createAdminRestApiClient({\n      scheme: config.hostScheme,\n      storeDomain: session.shop,\n      apiVersion: apiVersion ?? config.apiVersion,\n      accessToken: config.isCustomStoreApp\n        ? customStoreAppAccessToken\n        : session.accessToken!,\n      customFetchApi: abstractFetch,\n      logger: clientLoggerFactory(config),\n      userAgentPrefix: getUserAgent(config),\n      defaultRetryTime: this.restClass().RETRY_WAIT_TIME,\n      formatPaths: this.restClass().formatPaths,\n    });\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get<T = any>(params: GetRequestParams) {\n    return this.request<T>({method: Method.Get, ...params});\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post<T = any>(params: PostRequestParams) {\n    return this.request<T>({method: Method.Post, ...params});\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put<T = any>(params: PutRequestParams) {\n    return this.request<T>({method: Method.Put, ...params});\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete<T = any>(params: DeleteRequestParams) {\n    return this.request<T>({method: Method.Delete, ...params});\n  }\n\n  protected async request<T = any>(\n    params: RequestParams,\n  ): Promise<RestRequestReturn<T>> {\n    const requestParams = {\n      headers: {\n        ...params.extraHeaders,\n        ...(params.type ? {'Content-Type': params.type.toString()} : {}),\n      },\n      retries: params.tries ? params.tries - 1 : undefined,\n      searchParams: params.query,\n    };\n\n    let response: Response;\n    switch (params.method) {\n      case Method.Get:\n        response = await this.client.get(params.path, requestParams);\n        break;\n      case Method.Put:\n        response = await this.client.put(params.path, {\n          ...requestParams,\n          data: params.data!,\n        });\n        break;\n      case Method.Post:\n        response = await this.client.post(params.path, {\n          ...requestParams,\n          data: params.data!,\n        });\n        break;\n      case Method.Delete:\n        response = await this.client.delete(params.path, requestParams);\n        break;\n      default:\n        throw new ShopifyErrors.InvalidRequestError(\n          `Unsupported request method '${params.method}'`,\n        );\n    }\n\n    const body: any = await response.json();\n    const responseHeaders = canonicalizeHeaders(\n      Object.fromEntries(response.headers.entries()),\n    );\n\n    if (!response.ok) {\n      throwFailedRequest(body, (params.tries ?? 1) > 1, response);\n    }\n\n    const requestReturn: RestRequestReturn<T> = {\n      body,\n      headers: responseHeaders,\n    };\n\n    await this.logDeprecations(\n      {\n        method: params.method,\n        url: params.path,\n        headers: requestParams.headers,\n        body: params.data ? JSON.stringify(params.data) : undefined,\n      },\n      requestReturn,\n    );\n\n    const link = response.headers.get('Link');\n    if (link !== undefined) {\n      const pageInfo: PageInfo = {\n        limit: params.query?.limit\n          ? params.query?.limit.toString()\n          : RestClient.DEFAULT_LIMIT,\n      };\n\n      if (link) {\n        const links = link.split(', ');\n\n        for (const link of links) {\n          const parsedLink = link.match(RestClient.LINK_HEADER_REGEXP);\n          if (!parsedLink) {\n            continue;\n          }\n\n          const linkRel = parsedLink[2];\n          const linkUrl = new URL(parsedLink[1]);\n          const linkFields = linkUrl.searchParams.get('fields');\n          const linkPageToken = linkUrl.searchParams.get('page_info');\n\n          if (!pageInfo.fields && linkFields) {\n            pageInfo.fields = linkFields.split(',');\n          }\n\n          if (linkPageToken) {\n            switch (linkRel) {\n              case 'previous':\n                pageInfo.previousPageUrl = parsedLink[1];\n                pageInfo.prevPage = this.buildRequestParams(parsedLink[1]);\n                break;\n              case 'next':\n                pageInfo.nextPageUrl = parsedLink[1];\n                pageInfo.nextPage = this.buildRequestParams(parsedLink[1]);\n                break;\n            }\n          }\n        }\n      }\n\n      requestReturn.pageInfo = pageInfo;\n    }\n\n    return requestReturn;\n  }\n\n  private restClass() {\n    return this.constructor as typeof RestClient;\n  }\n\n  private buildRequestParams(newPageUrl: string): PageInfoParams {\n    const pattern = `^/admin/api/[^/]+/(.*).json$`;\n\n    const url = new URL(newPageUrl);\n    const path = url.pathname.replace(new RegExp(pattern), '$1');\n    return {\n      path,\n      query: Object.fromEntries(url.searchParams.entries()),\n    };\n  }\n\n  private async logDeprecations(\n    request: NormalizedRequest,\n    response: RestRequestReturn,\n  ) {\n    const config = this.restClass().config;\n\n    const deprecationReason = getHeader(\n      response.headers,\n      'X-Shopify-API-Deprecated-Reason',\n    );\n    if (deprecationReason) {\n      const deprecation: DeprecationInterface = {\n        message: deprecationReason,\n        path: request.url,\n      };\n\n      if (request.body) {\n        // This can only be a string, since we're always converting the body before calling this method\n        deprecation.body = `${(request.body as string).substring(0, 100)}...`;\n      }\n\n      const depHash = await createSHA256HMAC(\n        config.apiSecretKey,\n        JSON.stringify(deprecation),\n        HashFormat.Hex,\n      );\n\n      if (\n        !Object.keys(this.loggedDeprecations).includes(depHash) ||\n        Date.now() - this.loggedDeprecations[depHash] >=\n          RestClient.DEPRECATION_ALERT_DELAY\n      ) {\n        this.loggedDeprecations[depHash] = Date.now();\n\n        const stack = new Error().stack;\n        const message = `API Deprecation Notice ${new Date().toLocaleString()} : ${JSON.stringify(\n          deprecation,\n        )}  -  Stack Trace: ${stack}`;\n        await logger(config).warning(message);\n      }\n    }\n  }\n}"
          },
          "RestRequestReturn": {
            "filePath": "../shopify-api/lib/clients/admin/types.ts",
            "name": "RestRequestReturn",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "body",
                "value": "T",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Headers",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pageInfo",
                "value": "PageInfo",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface RestRequestReturn<T = any> {\n  body: T;\n  headers: Headers;\n  pageInfo?: PageInfo;\n}"
          },
          "Headers": {
            "filePath": "../shopify-api/runtime/http/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Headers",
            "value": "Record<string, string | string[]>",
            "description": "",
            "members": []
          },
          "PageInfo": {
            "filePath": "../shopify-api/lib/clients/admin/types.ts",
            "name": "PageInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "limit",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "fields",
                "value": "string[]",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "previousPageUrl",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nextPageUrl",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "prevPage",
                "value": "PageInfoParams",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nextPage",
                "value": "PageInfoParams",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface PageInfo {\n  limit: string;\n  fields?: string[];\n  previousPageUrl?: string;\n  nextPageUrl?: string;\n  prevPage?: PageInfoParams;\n  nextPage?: PageInfoParams;\n}"
          },
          "PageInfoParams": {
            "filePath": "../shopify-api/lib/clients/admin/types.ts",
            "name": "PageInfoParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": ""
              }
            ],
            "value": "export interface PageInfoParams {\n  path: string;\n  query: SearchParams;\n}"
          }
        }
      }
    ],
    "defaultExample": {
      "description": "Update a metafield when a product is updated",
      "codeblock": {
        "title": "Update a metafield when a product is updated",
        "tabs": [
          {
            "title": "/app/routes/**.ts",
            "language": "typescript",
            "code": "import {type ActionFunctionArgs} from '@remix-run/node';\n\nimport {authenticate} from '../shopify.server';\n\nexport const action = async ({request}: ActionFunctionArgs) =&gt; {\n  const {topic, admin, payload} = await authenticate.webhook(request);\n\n  switch (topic) {\n    case 'PRODUCTS_UPDATE':\n      await admin.graphql(\n        `#graphql\n        mutation setMetafield($productId: ID!, $time: String!) {\n          metafieldsSet(metafields: {\n            ownerId: $productId\n            namespace: \"my-app\",\n            key: \"webhook_received_at\",\n            value: $time,\n            type: \"string\",\n          }) {\n            metafields {\n              key\n              value\n            }\n          }\n        }\n        `,\n        {\n          variables: {\n            productId: payload.admin_graphql_api_id,\n            time: new Date().toISOString(),\n          },\n        },\n      );\n\n      return new Response();\n  }\n\n  throw new Response();\n};\n"
          }
        ]
      }
    },
    "jsDocTypeExamples": [
      "WebhookContextWithSession"
    ],
    "related": [
      {
        "name": "Admin API context",
        "subtitle": "Interact with the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/admin-api"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "admin",
          "examples": [
            {
              "description": "With the `v3_webhookAdminContext` future flag enabled, use the `admin` object in the context to interact with the Admin API.",
              "codeblock": {
                "title": "[V3] Webhook admin context",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.webhook(request);\n\n  const response = await admin?.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Use the `admin` object in the context to interact with the Admin API. This format will be removed in V3 of the package.",
              "codeblock": {
                "title": "Webhook admin context",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { json, ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.webhook(request);\n\n  const response = await admin?.graphql.query&lt;any&gt;({\n    data: {\n      query: `#graphql\n        mutation populateProduct($input: ProductInput!) {\n          productCreate(input: $input) {\n            product {\n              id\n            }\n          }\n        }`,\n      variables: { input: { title: \"Product Name\" } },\n    },\n  });\n\n  const productData = response?.body.data;\n  return json({ data: productData.data });\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "apiVersion",
          "examples": [
            {
              "description": "Get the API version used for webhook request.",
              "codeblock": {
                "title": "Webhook API version",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { apiVersion } = await authenticate.webhook(request);\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "shop",
          "examples": [
            {
              "description": "Get the shop that triggered a webhook.",
              "codeblock": {
                "title": "Webhook shop",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { shop } = await authenticate.webhook(request);\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "topic",
          "examples": [
            {
              "description": "Get the event topic for the webhook.",
              "codeblock": {
                "title": "Webhook topic",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { topic } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      // Do something when the app is uninstalled.\n      break;\n  }\n\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "webhookId",
          "examples": [
            {
              "description": "Get the webhook ID.",
              "codeblock": {
                "title": "Webhook ID",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { webhookId } = await authenticate.webhook(request);\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "payload",
          "examples": [
            {
              "description": "Get the request's POST payload.",
              "codeblock": {
                "title": "Webhook payload",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { payload } = await authenticate.webhook(request);\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "subTopic",
          "examples": [
            {
              "description": "Get the webhook sub-topic.",
              "codeblock": {
                "title": "Webhook sub-topic",
                "tabs": [
                  {
                    "title": "/app/routes/webhooks.tsx",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { subTopic } = await authenticate.webhook(request);\n  return new Response();\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Admin API",
    "description": "Contains objects used to interact with the Admin API.\n\nThis object is returned as part of different contexts, such as [`admin`](/docs/api/shopify-app-remix/authenticate/admin), [`unauthenticated.admin`](/docs/api/shopify-app-remix/unauthenticated/unauthenticated-admin), and [`webhook`](/docs/api/shopify-app-remix/authenticate/webhook).",
    "category": "APIs",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "admin",
        "description": "Provides utilities that apps can use to make requests to the Admin API.",
        "type": "AdminApiContext",
        "typeDefinitions": {
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "AdminApiContext"
    ],
    "related": [
      {
        "name": "Authenticated context",
        "subtitle": "Authenticate requests from Shopify Admin.",
        "url": "/docs/api/shopify-app-remix/authenticate/admin"
      },
      {
        "name": "Unauthenticated context",
        "subtitle": "Interact with the Admin API on non-Shopify requests.",
        "url": "/docs/api/shopify-app-remix/unauthenticated/unauthenticated-admin"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "rest",
          "examples": [
            {
              "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
              "codeblock": {
                "title": "Using REST resources",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
              "codeblock": {
                "title": "Performing a GET request to the REST API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
              "codeblock": {
                "title": "Performing a POST request to the REST API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "graphql",
          "examples": [
            {
              "description": "Use `admin.graphql` to make query / mutation requests.",
              "codeblock": {
                "title": "Querying the GraphQL API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
              "codeblock": {
                "title": "Handling GraphQL errors",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Storefront API",
    "description": "Contains objects used to interact with the Storefront API.\n\nThis object is returned as part of different contexts, such as [`appProxy`](/docs/api/shopify-app-remix/authenticate/public/app-proxy), and [`unauthenticated.storefront`](/docs/api/shopify-app-remix/unauthenticated/unauthenticated-storefront).",
    "category": "APIs",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "storefront",
        "description": "Provides utilities that apps can use to make requests to the Storefront API.",
        "type": "StorefrontContext",
        "typeDefinitions": {
          "StorefrontContext": {
            "filePath": "src/server/clients/storefront/types.ts",
            "name": "StorefrontContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<StorefrontOperations>",
                "description": "Method for interacting with the Shopify Storefront GraphQL API\n\nIf you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `storefront.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  try {\n    const response = await storefront.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // { errors: { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] } }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface StorefrontContext {\n  /**\n   * Method for interacting with the Shopify Storefront GraphQL API\n   *\n   * If you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n   *\n   * {@link https://shopify.dev/docs/api/storefront}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `storefront.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   try {\n   *     const response = await storefront.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // { errors: { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] } }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<StorefrontOperations>;\n}"
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "StorefrontContext"
    ],
    "related": [
      {
        "name": "App proxy context",
        "subtitle": "Authenticate requests from Shopify app proxies.",
        "url": "/docs/api/shopify-app-remix/authenticate/public/app-proxy"
      },
      {
        "name": "Unauthenticated context",
        "subtitle": "Interact with the Storefront API on non-Shopify requests.",
        "url": "/docs/api/shopify-app-remix/unauthenticated/unauthenticated-storefront"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "graphql",
          "examples": [
            {
              "description": "Use `storefront.graphql` to make query / mutation requests.",
              "codeblock": {
                "title": "Querying the GraphQL API",
                "tabs": [
                  {
                    "title": "app/routes/**\\/.ts",
                    "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
              "codeblock": {
                "title": "Handling GraphQL errors",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  try {\n    const response = await storefront.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // { errors: { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] } }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "shopifyApp",
    "description": "Returns a set of functions that can be used by the app's backend to be able to respond to all Shopify requests.\n\nThe shape of the returned object changes depending on the value of `distribution`. If it is `AppDistribution.ShopifyAdmin`, then only `ShopifyAppBase` objects are returned, otherwise `ShopifyAppLogin` objects are included.",
    "category": "Entrypoints",
    "type": "function",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "shopifyApp",
        "description": "Function to create a new Shopify API object.",
        "type": "ShopifyAppGeneratedType",
        "typeDefinitions": {
          "ShopifyAppGeneratedType": {
            "filePath": "src/server/shopify-app.ts",
            "name": "ShopifyAppGeneratedType",
            "description": "Creates an object your app will use to interact with Shopify.",
            "params": [
              {
                "name": "appConfig",
                "description": "Configuration options for your Shopify app, such as the scopes your app needs.",
                "value": "Readonly<Config>",
                "filePath": "src/server/shopify-app.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/shopify-app.ts",
              "description": "`ShopifyApp` An object constructed using your appConfig.  It has methods for interacting with Shopify.",
              "name": "ShopifyApp<Config extends AppConfigArg<Resources, Storage, Future>>",
              "value": "ShopifyApp<Config extends AppConfigArg<Resources, Storage, Future>>"
            },
            "value": "export function shopifyApp<\n  Config extends AppConfigArg<Resources, Storage, Future>,\n  Resources extends ShopifyRestResources,\n  Storage extends SessionStorage,\n  Future extends FutureFlagOptions = Config['future'],\n>(appConfig: Readonly<Config>): ShopifyApp<Config> {\n  const api = deriveApi(appConfig);\n  const config = deriveConfig<Storage>(appConfig, api.config);\n  const logger = overrideLogger(api.logger);\n\n  if (appConfig.webhooks) {\n    api.webhooks.addHandlers(appConfig.webhooks);\n  }\n\n  const params: BasicParams = {api, config, logger};\n  const authStrategy = authStrategyFactory<Config, Resources>({\n    ...params,\n    strategy:\n      config.future.unstable_newEmbeddedAuthStrategy && config.isEmbeddedApp\n        ? new TokenExchangeStrategy(params)\n        : new AuthCodeFlowStrategy(params),\n  });\n\n  const shopify:\n    | AdminApp<Config>\n    | AppStoreApp<Config>\n    | SingleMerchantApp<Config> = {\n    sessionStorage: config.sessionStorage,\n    addDocumentResponseHeaders: addDocumentResponseHeadersFactory(params),\n    registerWebhooks: registerWebhooksFactory(params),\n    authenticate: {\n      admin: authStrategy,\n      flow: authenticateFlowFactory<Resources>(params),\n      public: authenticatePublicFactory<Future, Resources>(params),\n      fulfillmentService:\n        authenticateFulfillmentServiceFactory<Resources>(params),\n      webhook: authenticateWebhookFactory<\n        Future,\n        Resources,\n        keyof Config['webhooks'] | MandatoryTopics\n      >(params),\n    },\n    unauthenticated: {\n      admin: unauthenticatedAdminContextFactory(params),\n      storefront: unauthenticatedStorefrontContextFactory(params),\n    },\n  };\n\n  if (\n    isAppStoreApp(shopify, appConfig) ||\n    isSingleMerchantApp(shopify, appConfig)\n  ) {\n    shopify.login = loginFactory(params);\n  }\n\n  logDisabledFutureFlags(config, logger);\n\n  return shopify as ShopifyApp<Config>;\n}",
            "examples": [
              {
                "title": "The minimum viable configuration",
                "description": "",
                "tabs": [
                  {
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  apiKey: process.env.SHOPIFY_API_KEY!,\n  apiSecretKey: process.env.SHOPIFY_API_SECRET!,\n  scopes: process.env.SCOPES?.split(\",\")!,\n  appUrl: process.env.SHOPIFY_APP_URL!,\n});\nexport default shopify;",
                    "title": "/shopify.server.ts"
                  }
                ]
              }
            ]
          },
          "ShopifyApp": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyApp",
            "value": "Config['distribution'] extends AppDistribution.ShopifyAdmin\n    ? AdminApp<Config>\n    : Config['distribution'] extends AppDistribution.SingleMerchant\n      ? SingleMerchantApp<Config>\n      : Config['distribution'] extends AppDistribution.AppStore\n        ? AppStoreApp<Config>\n        : AppStoreApp<Config>",
            "description": "An object your app can use to interact with Shopify.\n\nBy default, the app's distribution is `AppStore`."
          },
          "AppDistribution": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "AppDistribution",
            "value": "export enum AppDistribution {\n  AppStore = 'app_store',\n  SingleMerchant = 'single_merchant',\n  ShopifyAdmin = 'shopify_admin',\n}",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "name": "AppStore",
                "value": "app_store"
              },
              {
                "filePath": "src/server/types.ts",
                "name": "SingleMerchant",
                "value": "single_merchant"
              },
              {
                "filePath": "src/server/types.ts",
                "name": "ShopifyAdmin",
                "value": "shopify_admin"
              }
            ]
          },
          "AdminApp": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AdminApp",
            "value": "ShopifyAppBase<Config>",
            "description": "",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionStorage",
                "value": "SessionStorageType<Config>",
                "description": "The `SessionStorage` instance you passed in as a config option.",
                "examples": [
                  {
                    "title": "Storing sessions with Prisma",
                    "description": "Import the `@shopify/shopify-app-session-storage-prisma` package to store sessions in your Prisma database.",
                    "tabs": [
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\nimport prisma from \"~/db.server\";\n\nconst shopify = shopifyApp({\n  sessionStorage: new PrismaSessionStorage(prisma),\n  // ...etc\n})\n\n// shopify.sessionStorage is an instance of PrismaSessionStorage",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "addDocumentResponseHeaders",
                "value": "AddDocumentResponseHeaders",
                "description": "Adds the required Content Security Policy headers for Shopify apps to the given Headers object.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Return headers on all requests",
                    "description": "Add headers to all HTML requests by calling `shopify.addDocumentResponseHeaders` in `entry.server.tsx`.",
                    "tabs": [
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const addDocumentResponseheaders = shopify.addDocumentResponseheaders;",
                        "title": "~/shopify.server.ts"
                      },
                      {
                        "code": "import { addDocumentResponseHeaders } from \"~/shopify.server\";\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  const markup = renderToString(\n    <RemixServer context={remixContext} url={request.url} />\n  );\n\n  responseHeaders.set(\"Content-Type\", \"text/html\");\n  addDocumentResponseHeaders(request, responseHeaders);\n\n  return new Response(\"<!DOCTYPE html>\" + markup, {\n    status: responseStatusCode,\n    headers: responseHeaders,\n  });\n}",
                        "title": "entry.server.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "registerWebhooks",
                "value": "RegisterWebhooks",
                "description": "Register webhook topics for a store using the given session. Most likely you want to use this in combination with the afterAuth hook.",
                "examples": [
                  {
                    "title": "Registering webhooks after install",
                    "description": "Trigger the registration to create the webhook subscriptions after a merchant installs your app using the `afterAuth` hook. Learn more about [subscribing to webhooks.](/docs/api/shopify-app-remix/v1/guide-webhooks)",
                    "tabs": [
                      {
                        "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  hooks: {\n    afterAuth: async ({ session }) => {\n      shopify.registerWebhooks({ session });\n    }\n  },\n  webhooks: {\n    APP_UNINSTALLED: {\n      deliveryMethod: DeliveryMethod.Http,\n       callbackUrl: \"/webhooks\",\n    },\n  },\n  // ...etc\n});",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authenticate",
                "value": "Authenticate<Config>",
                "description": "Ways to authenticate requests from different surfaces across Shopify.",
                "examples": [
                  {
                    "title": "Authenticate Shopify requests",
                    "description": "Use the functions in `authenticate` to validate requests coming from Shopify.",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const {admin, session, sessionToken, billing} = shopify.authenticate.admin(request);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "unauthenticated",
                "value": "Unauthenticated<RestResourcesType<Config>>",
                "description": "Ways to get Contexts from requests that do not originate from Shopify.",
                "examples": [
                  {
                    "title": "Using unauthenticated contexts",
                    "description": "Create contexts for requests that don't come from Shopify.",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticateExternal } from \"~/helpers/authenticate\"\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const shop = await authenticateExternal(request)\n  const {admin} = await shopify.unauthenticated.admin(shop);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "SessionStorageType": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SessionStorageType",
            "value": "Config['sessionStorage'] extends SessionStorage\n    ? Config['sessionStorage']\n    : SessionStorage",
            "description": ""
          },
          "AddDocumentResponseHeaders": {
            "filePath": "src/server/types.ts",
            "name": "AddDocumentResponseHeaders",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/types.ts"
              },
              {
                "name": "headers",
                "description": "",
                "value": "Headers",
                "filePath": "src/server/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/types.ts",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type AddDocumentResponseHeaders = (request: Request, headers: Headers) => void;"
          },
          "Headers": {
            "filePath": "../shopify-api/runtime/http/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Headers",
            "value": "Record<string, string | string[]>",
            "description": "",
            "members": []
          },
          "RegisterWebhooks": {
            "filePath": "src/server/types.ts",
            "name": "RegisterWebhooks",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "RegisterWebhooksOptions",
                "filePath": "src/server/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/types.ts",
              "description": "",
              "name": "Promise<RegisterReturn | void>",
              "value": "Promise<RegisterReturn | void>"
            },
            "value": "type RegisterWebhooks = (\n  options: RegisterWebhooksOptions,\n) => Promise<RegisterReturn | void>;"
          },
          "RegisterWebhooksOptions": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "RegisterWebhooksOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The Shopify session used to register webhooks using the Admin API."
              }
            ],
            "value": "export interface RegisterWebhooksOptions {\n  /**\n   * The Shopify session used to register webhooks using the Admin API.\n   */\n  session: Session;\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "RegisterReturn": {
            "filePath": "../shopify-api/lib/webhooks/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RegisterReturn",
            "value": "Record<string, RegisterResult[]>",
            "description": "",
            "members": []
          },
          "Authenticate": {
            "filePath": "src/server/types.ts",
            "name": "Authenticate",
            "description": "",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AuthenticateAdmin<Config, RestResourcesType<Config>>",
                "description": "Authenticate an admin Request and get back an authenticated admin context.  Use the authenticated admin context to interact with Shopify.\n\nExamples of when to use this are requests from your app's UI, or requests from admin extensions.\n\nIf there is no session for the Request, this will redirect the merchant to correct auth flows.",
                "examples": [
                  {
                    "title": "Authenticating a request for an embedded app",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const {admin, session, sessionToken, billing} = authenticate.admin(request);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      },
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "flow",
                "value": "AuthenticateFlow<RestResourcesType<Config>>",
                "description": "Authenticate a Flow extension Request and get back an authenticated context, containing an admin context to access the API, and the payload of the request.\n\nIf there is no session for the Request, this will return an HTTP 400 error.\n\nNote that this will always be a POST request.",
                "examples": [
                  {
                    "title": "Authenticating a Flow extension request",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const {admin, session, payload} = authenticate.flow(request);\n\n  // Perform flow extension logic\n\n  // Return a 200 response\n  return null;\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      },
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "fulfillmentService",
                "value": "AuthenticateFulfillmentService<RestResourcesType<Config>>",
                "description": "Authenticate a request from a fulfillment service and get back an authenticated context.",
                "examples": [
                  {
                    "title": "Shopify session for the fulfillment service request",
                    "description": "Use the session associated with this request to use the Admin GraphQL API",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.fulfillmentService(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation acceptFulfillmentRequest {\n      fulfillmentOrderAcceptFulfillmentRequest(\n           id: \"gid://shopify/FulfillmentOrder/5014440902678\",\n           message: \"Reminder that tomorrow is a holiday. We won't be able to ship this until Monday.\"){\n            fulfillmentOrder {\n                status\n               requestStatus\n           }\n        }\n    }\n   );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/fulfillment_order_notification.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "public",
                "value": "AuthenticatePublic<Config['future']>",
                "description": "Authenticate a public request and get back a session token.",
                "examples": [
                  {
                    "title": "Authenticating a request from a checkout extension",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../../shopify.server\";\nimport { getWidgets } from \"~/db/widgets\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const {sessionToken} = authenticate.public.checkout(request);\n\n  return json(await getWidgets(sessionToken));\n}",
                        "title": "/app/routes/api/checkout.jsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "webhook",
                "value": "AuthenticateWebhook<\n    Config['future'],\n    RestResourcesType<Config>,\n    keyof Config['webhooks'] | MandatoryTopics\n  >",
                "description": "Authenticate a Shopify webhook request, get back an authenticated admin context and details on the webhook request",
                "examples": [
                  {
                    "title": "Authenticating a webhook request",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  webhooks: {\n   APP_UNINSTALLED: {\n      deliveryMethod: DeliveryMethod.Http,\n      callbackUrl: \"/webhooks\",\n    },\n  },\n  hooks: {\n    afterAuth: async ({ session }) => {\n      shopify.registerWebhooks({ session });\n    },\n  },\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport db from \"../db.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { topic, shop, session } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      if (session) {\n        await db.session.deleteMany({ where: { shop } });\n      }\n      break;\n    case \"CUSTOMERS_DATA_REQUEST\":\n    case \"CUSTOMERS_REDACT\":\n    case \"SHOP_REDACT\":\n    default:\n      throw new Response(\"Unhandled webhook topic\", { status: 404 });\n  }\n\n  throw new Response();\n};",
                        "title": "/app/routes/webhooks.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "interface Authenticate<Config extends AppConfigArg> {\n  /**\n   * Authenticate an admin Request and get back an authenticated admin context.  Use the authenticated admin context to interact with Shopify.\n   *\n   * Examples of when to use this are requests from your app's UI, or requests from admin extensions.\n   *\n   * If there is no session for the Request, this will redirect the merchant to correct auth flows.\n   *\n   * @example\n   * <caption>Authenticating a request for an embedded app.</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {admin, session, sessionToken, billing} = authenticate.admin(request);\n   *\n   *   return json(await admin.rest.resources.Product.count({ session }));\n   * }\n   * ```\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  admin: AuthenticateAdmin<Config, RestResourcesType<Config>>;\n\n  /**\n   * Authenticate a Flow extension Request and get back an authenticated context, containing an admin context to access\n   * the API, and the payload of the request.\n   *\n   * If there is no session for the Request, this will return an HTTP 400 error.\n   *\n   * Note that this will always be a POST request.\n   *\n   * @example\n   * <caption>Authenticating a Flow extension request.</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { ActionFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const {admin, session, payload} = authenticate.flow(request);\n   *\n   *   // Perform flow extension logic\n   *\n   *   // Return a 200 response\n   *   return null;\n   * }\n   * ```\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  flow: AuthenticateFlow<RestResourcesType<Config>>;\n\n  /**\n   * Authenticate a request from a fulfillment service and get back an authenticated context.\n   *\n   * @example\n   * <caption>Shopify session for the fulfillment service request.</caption>\n   * <description>Use the session associated with this request to use the Admin GraphQL API </description>\n   * ```ts\n   * // /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.fulfillmentService(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation acceptFulfillmentRequest {\n   *       fulfillmentOrderAcceptFulfillmentRequest(\n   *            id: \"gid://shopify/FulfillmentOrder/5014440902678\",\n   *            message: \"Reminder that tomorrow is a holiday. We won't be able to ship this until Monday.\"){\n   *             fulfillmentOrder {\n   *                 status\n   *                requestStatus\n   *            }\n   *         }\n   *     }\n   *    );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   * */\n  fulfillmentService: AuthenticateFulfillmentService<RestResourcesType<Config>>;\n\n  /**\n   * Authenticate a public request and get back a session token.\n   *\n   * @example\n   * <caption>Authenticating a request from a checkout extension</caption>\n   *\n   * ```ts\n   * // /app/routes/api/checkout.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   * import { getWidgets } from \"~/db/widgets\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {sessionToken} = authenticate.public.checkout(request);\n   *\n   *   return json(await getWidgets(sessionToken));\n   * }\n   * ```\n   */\n  public: AuthenticatePublic<Config['future']>;\n\n  /**\n   * Authenticate a Shopify webhook request, get back an authenticated admin context and details on the webhook request\n   *\n   * @example\n   * <caption>Authenticating a webhook request</caption>\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   webhooks: {\n   *    APP_UNINSTALLED: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *       callbackUrl: \"/webhooks\",\n   *     },\n   *   },\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       shopify.registerWebhooks({ session });\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   * ```ts\n   * // /app/routes/webhooks.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import db from \"../db.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { topic, shop, session } = await authenticate.webhook(request);\n   *\n   *   switch (topic) {\n   *     case \"APP_UNINSTALLED\":\n   *       if (session) {\n   *         await db.session.deleteMany({ where: { shop } });\n   *       }\n   *       break;\n   *     case \"CUSTOMERS_DATA_REQUEST\":\n   *     case \"CUSTOMERS_REDACT\":\n   *     case \"SHOP_REDACT\":\n   *     default:\n   *       throw new Response(\"Unhandled webhook topic\", { status: 404 });\n   *   }\n   *\n   *   throw new Response();\n   * };\n   * ```\n   */\n  webhook: AuthenticateWebhook<\n    Config['future'],\n    RestResourcesType<Config>,\n    keyof Config['webhooks'] | MandatoryTopics\n  >;\n}"
          },
          "AuthenticateAdmin": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "AuthenticateAdmin",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/admin/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/admin/types.ts",
              "description": "",
              "name": "Promise<AdminContext<Config, Resources>>",
              "value": "Promise<AdminContext<Config, Resources>>"
            },
            "value": "export type AuthenticateAdmin<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> = (request: Request) => Promise<AdminContext<Config, Resources>>;"
          },
          "AdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AdminContext",
            "value": "Config['isEmbeddedApp'] extends false\n  ? NonEmbeddedAdminContext<Config, Resources>\n  : EmbeddedAdminContext<Config, Resources>",
            "description": ""
          },
          "NonEmbeddedAdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "NonEmbeddedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the user who made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using offline sessions",
                    "description": "Get your app's shop-specific data using an offline session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Using online sessions",
                    "description": "Get your app's user-specific data using an online session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request."
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingContext<Config>",
                "description": "Billing methods for this store, based on the plans defined in the `billing` config option.\n\n\n\n\n"
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a admin request",
                    "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface NonEmbeddedAdminContext<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends AdminContextInternal<Config, Resources> {}"
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          },
          "BillingContext": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "BillingContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "require",
                "value": "(options: RequireBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Requesting billing right away",
                    "description": "Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirect to a plan selection page",
                    "description": "When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n    isTest: true,\n    onFailure: () => redirect('/select-plan'),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Requesting billing with line items",
                    "description": "Call `billing.request` with the `v3_lineItemBilling` future flag enabled",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    isTest: true,\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      lineItems: [\n       {\n         amount: 5,\n         currencyCode: 'USD',\n         interval: BillingInterval.Every30Days,\n        },\n        {\n         amount: 1,\n         currencyCode: 'USD',\n         interval: BillingInterval.Usage.\n         terms: '1 dollar per 1000 emails',\n        },\n      ],\n    },\n  }\n future: {v3_lineItemBilling: true}\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "check",
                "value": "(options: CheckBillingOptions<Config>) => Promise<BillingCheckResponseObject>",
                "description": "Checks if the shop has an active payment for any plan defined in the `billing` config option.",
                "examples": [
                  {
                    "title": "Check what billing plans a merchant is subscribed to",
                    "description": "Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does notthrow an error if no active billing plans are present.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const { hasActivePayment, appSubscriptions } = await billing.check({\n    plans: [MONTHLY_PLAN],\n    isTest: false,\n  });\n console.log(hasActivePayment)\n console.log(appSubscriptions)\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "(options: RequestBillingOptions<Config>) => Promise<never>",
                "description": "Requests payment for the plan.",
                "examples": [
                  {
                    "title": "Using a custom return URL",
                    "description": "Change where the merchant is returned to after approving the purchase using the `returnUrl` option.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({\n      plan: MONTHLY_PLAN,\n      isTest: true,\n      returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n    }),\n  });\n\n  // App logic\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cancel",
                "value": "(options: CancelBillingOptions) => Promise<AppSubscription>",
                "description": "Cancels an ongoing subscription, given its ID.",
                "examples": [
                  {
                    "title": "Cancelling a subscription",
                    "description": "Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { billing } = await authenticate.admin(request);\n  const billingCheck = await billing.require({\n    plans: [MONTHLY_PLAN],\n    onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n  });\n\n  const subscription = billingCheck.appSubscriptions[0];\n  const cancelledSubscription = await billing.cancel({\n    subscriptionId: subscription.id,\n    isTest: true,\n    prorate: true,\n   });\n\n  // App logic\n};",
                        "title": "/app/routes/cancel-subscription.ts"
                      },
                      {
                        "code": "import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n\nexport const MONTHLY_PLAN = 'Monthly subscription';\nexport const ANNUAL_PLAN = 'Annual subscription';\n\nconst shopify = shopifyApp({\n  // ...etc\n  billing: {\n    [MONTHLY_PLAN]: {\n      amount: 5,\n      currencyCode: 'USD',\n      interval: BillingInterval.Every30Days,\n    },\n    [ANNUAL_PLAN]: {\n      amount: 50,\n      currencyCode: 'USD',\n      interval: BillingInterval.Annual,\n    },\n  }\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface BillingContext<Config extends AppConfigArg> {\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Requesting billing right away.</caption>\n   * <description>Call `billing.request` in the `onFailure` callback to immediately redirect to the Shopify page to request payment.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Redirect to a plan selection page.</caption>\n   * <description> When the app has multiple plans, create a page in your App that allows the merchant to select a plan. If a merchant does not have the required plan you can redirect them to page in your app to select one.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, redirect } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN, ANNUAL_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN, ANNUAL_PLAN],\n   *     isTest: true,\n   *     onFailure: () => redirect('/select-plan'),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   console.log(`Shop is on ${subscription.name} (id ${subscription.id})`);\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   * @example\n   * <caption>Requesting billing with line items</caption>\n   * <description>Call `billing.request` with the `v3_lineItemBilling` future flag enabled</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: true,\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       lineItems: [\n   *        {\n   *          amount: 5,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Every30Days,\n   *         },\n   *         {\n   *          amount: 1,\n   *          currencyCode: 'USD',\n   *          interval: BillingInterval.Usage.\n   *          terms: '1 dollar per 1000 emails',\n   *         },\n   *       ],\n   *     },\n   *   }\n   *  future: {v3_lineItemBilling: true}\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  require: (\n    options: RequireBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Checks if the shop has an active payment for any plan defined in the `billing` config option.\n   *\n   * @returns A promise that resolves to an object containing the active purchases for the shop.\n   *\n   * @example\n   * <caption>Check what billing plans a merchant is subscribed to.</caption>\n   * <description>Use billing.check if you want to determine which plans are in use. Unlike `require`, `check` does not\n   * throw an error if no active billing plans are present. </description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const { hasActivePayment, appSubscriptions } = await billing.check({\n   *     plans: [MONTHLY_PLAN],\n   *     isTest: false,\n   *   });\n   *  console.log(hasActivePayment)\n   *  console.log(appSubscriptions)\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   */\n  check: (\n    options: CheckBillingOptions<Config>,\n  ) => Promise<BillingCheckResponseObject>;\n\n  /**\n   * Requests payment for the plan.\n   *\n   * @returns Redirects to the confirmation URL for the payment.\n   *\n   * @example\n   * <caption>Using a custom return URL.</caption>\n   * <description>Change where the merchant is returned to after approving the purchase using the `returnUrl` option.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({\n   *       plan: MONTHLY_PLAN,\n   *       isTest: true,\n   *       returnUrl: 'https://admin.shopify.com/store/my-store/apps/my-app/billing-page',\n   *     }),\n   *   });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  request: (options: RequestBillingOptions<Config>) => Promise<never>;\n\n  /**\n   * Cancels an ongoing subscription, given its ID.\n   *\n   * @returns The cancelled subscription.\n   *\n   * @example\n   * <caption>Cancelling a subscription.</caption>\n   * <description>Use the `billing.cancel` function to cancel an active subscription with the id returned from `billing.require`.</description>\n   * ```ts\n   * // /app/routes/cancel-subscription.ts\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate, MONTHLY_PLAN } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { billing } = await authenticate.admin(request);\n   *   const billingCheck = await billing.require({\n   *     plans: [MONTHLY_PLAN],\n   *     onFailure: async () => billing.request({ plan: MONTHLY_PLAN }),\n   *   });\n   *\n   *   const subscription = billingCheck.appSubscriptions[0];\n   *   const cancelledSubscription = await billing.cancel({\n   *     subscriptionId: subscription.id,\n   *     isTest: true,\n   *     prorate: true,\n   *    });\n   *\n   *   // App logic\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp, BillingInterval } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const MONTHLY_PLAN = 'Monthly subscription';\n   * export const ANNUAL_PLAN = 'Annual subscription';\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   billing: {\n   *     [MONTHLY_PLAN]: {\n   *       amount: 5,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Every30Days,\n   *     },\n   *     [ANNUAL_PLAN]: {\n   *       amount: 50,\n   *       currencyCode: 'USD',\n   *       interval: BillingInterval.Annual,\n   *     },\n   *   }\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  cancel: (options: CancelBillingOptions) => Promise<AppSubscription>;\n}"
          },
          "RequireBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequireBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onFailure",
                "value": "(error: any) => Promise<Response>",
                "description": "How to handle the request if the shop doesn't have an active payment for any plan."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface RequireBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n  /**\n   * How to handle the request if the shop doesn't have an active payment for any plan.\n   */\n  onFailure: (error: any) => Promise<Response>;\n}"
          },
          "BillingCheckResponseObject": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingCheckResponseObject",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hasActivePayment",
                "value": "boolean",
                "description": "Whether the user has an active payment method."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "oneTimePurchases",
                "value": "OneTimePurchase[]",
                "description": "The one-time purchases the shop has."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "appSubscriptions",
                "value": "AppSubscription[]",
                "description": "The active subscriptions the shop has."
              }
            ],
            "value": "export interface BillingCheckResponseObject {\n  /**\n   * Whether the user has an active payment method.\n   */\n  hasActivePayment: boolean;\n  /**\n   * The one-time purchases the shop has.\n   */\n  oneTimePurchases: OneTimePurchase[];\n  /**\n   * The active subscriptions the shop has.\n   */\n  appSubscriptions: AppSubscription[];\n}"
          },
          "OneTimePurchase": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "OneTimePurchase",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the one-time purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test purchase."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "status",
                "value": "string",
                "description": "The status of the one-time purchase."
              }
            ],
            "value": "export interface OneTimePurchase {\n  /**\n   * The ID of the one-time purchase.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  test: boolean;\n  /**\n   * The status of the one-time purchase.\n   */\n  status: string;\n}"
          },
          "AppSubscription": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppSubscription",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The ID of the app subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "The name of the purchased plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "test",
                "value": "boolean",
                "description": "Whether this is a test subscription."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "lineItems",
                "value": "ActiveSubscriptionLineItem[]",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface AppSubscription {\n  /**\n   * The ID of the app subscription.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test subscription.\n   */\n  test: boolean;\n\n  /*\n   * The line items for this plan. This will become mandatory in v10.\n   */\n  lineItems?: ActiveSubscriptionLineItem[];\n}"
          },
          "ActiveSubscriptionLineItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "ActiveSubscriptionLineItem",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "AppPlan",
                "description": ""
              }
            ],
            "value": "export interface ActiveSubscriptionLineItem {\n  /*\n   * The ID of the line item.\n   */\n  id: string;\n  /*\n   * The details of the plan.\n   */\n  plan: AppPlan;\n}"
          },
          "AppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pricingDetails",
                "value": "RecurringAppPlan | UsageAppPlan",
                "description": ""
              }
            ],
            "value": "export interface AppPlan {\n  /*\n   * The pricing details of the plan.\n   */\n  pricingDetails: RecurringAppPlan | UsageAppPlan;\n}"
          },
          "RecurringAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "RecurringAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Every30Days | BillingInterval.Annual",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "discount",
                "value": "AppPlanDiscount",
                "description": ""
              }
            ],
            "value": "export interface RecurringAppPlan {\n  /*\n   * The interval for this plan is charged on.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /*\n   * The price of the plan.\n   */\n  price: Money;\n  /*\n   * The discount applied to the plan.\n   */\n  discount: AppPlanDiscount;\n}"
          },
          "BillingInterval": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "BillingInterval",
            "value": "export enum BillingInterval {\n  OneTime = 'ONE_TIME',\n  Every30Days = 'EVERY_30_DAYS',\n  Annual = 'ANNUAL',\n  Usage = 'USAGE',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "OneTime",
                "value": "ONE_TIME"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Every30Days",
                "value": "EVERY_30_DAYS"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Annual",
                "value": "ANNUAL"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Usage",
                "value": "USAGE"
              }
            ]
          },
          "Money": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "Money",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": ""
              }
            ],
            "value": "interface Money {\n  amount: number;\n  currencyCode: string;\n}"
          },
          "AppPlanDiscount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "AppPlanDiscount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "durationLimitInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "remainingDurationInIntervals",
                "value": "number",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "priceAfterDiscount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "AppPlanDiscountAmount",
                "description": ""
              }
            ],
            "value": "export interface AppPlanDiscount {\n  /*\n   * The total number of intervals the discount applies to.\n   */\n  durationLimitInIntervals: number;\n  /*\n   * The remaining number of intervals the discount applies to.\n   */\n  remainingDurationInIntervals: number;\n  /*\n   * The price after the discount is applied.\n   */\n  priceAfterDiscount: Money;\n  /*\n   * The value of the discount applied every billing interval.\n   */\n  value: AppPlanDiscountAmount;\n}"
          },
          "AppPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AppPlanDiscountAmount",
            "value": "BillingConfigSubscriptionPlanDiscountAmount | BillingConfigSubscriptionPlanDiscountPercentage",
            "description": ""
          },
          "BillingConfigSubscriptionPlanDiscountAmount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountAmount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "never",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set.",
                "isOptional": true
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountAmount {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount: number;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage?: never;\n}"
          },
          "BillingConfigSubscriptionPlanDiscountPercentage": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscountPercentage",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "never",
                "description": "The amount to discount.\n\nCannot be set if `percentage` is set.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "percentage",
                "value": "number",
                "description": "The percentage to discount.\n\nCannot be set if `amount` is set."
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscountPercentage {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount?: never;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage: number;\n}"
          },
          "UsageAppPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "UsageAppPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "balanceUsed",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cappedAmount",
                "value": "Money",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "terms",
                "value": "string",
                "description": ""
              }
            ],
            "value": "export interface UsageAppPlan {\n  /*\n   * The total usage records for interval.\n   */\n  balanceUsed: Money;\n  /*\n   * The capped amount prevents the merchant from being charged for any usage over that amount during a billing period.\n   */\n  cappedAmount: Money;\n  /*\n   * The terms and conditions for app usage pricing.\n   */\n  terms: string;\n}"
          },
          "CheckBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CheckBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plans",
                "value": "(keyof Config[\"billing\"])[]",
                "description": "The plans to check for. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to consider test purchases.",
                "isOptional": true
              }
            ],
            "value": "export interface CheckBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingCheckParams, 'session' | 'plans' | 'returnObject'> {\n  /**\n   * The plans to check for. Must be one of the values defined in the `billing` config option.\n   */\n  plans: (keyof Config['billing'])[];\n}"
          },
          "RequestBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "RequestBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "plan",
                "value": "keyof Config[\"billing\"]",
                "description": "The plan to request. Must be one of the values defined in the `billing` config option."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "returnUrl",
                "value": "string",
                "description": "The URL to return to after the merchant approves the payment.",
                "isOptional": true
              }
            ],
            "value": "export interface RequestBillingOptions<Config extends AppConfigArg>\n  extends Omit<BillingRequestParams, 'session' | 'plan' | 'returnObject'> {\n  /**\n   * The plan to request. Must be one of the values defined in the `billing` config option.\n   */\n  plan: keyof Config['billing'];\n  /**\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n  /**\n   * The URL to return to after the merchant approves the payment.\n   */\n  returnUrl?: string;\n}"
          },
          "CancelBillingOptions": {
            "filePath": "src/server/authenticate/admin/billing/types.ts",
            "name": "CancelBillingOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subscriptionId",
                "value": "string",
                "description": "The ID of the subscription to cancel."
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "prorate",
                "value": "boolean",
                "description": "Whether to prorate the cancellation.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/server/authenticate/admin/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isTest",
                "value": "boolean",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface CancelBillingOptions {\n  /**\n   * The ID of the subscription to cancel.\n   */\n  subscriptionId: string;\n  /**\n   * Whether to prorate the cancellation.\n   *\n   * {@link https://shopify.dev/docs/apps/billing/subscriptions/cancel-recurring-charges}\n   */\n  prorate?: boolean;\n  /*\n   * Whether to use the test mode. This prevents the credit card from being charged. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n}"
          },
          "EnsureCORSFunction": {
            "filePath": "src/server/authenticate/helpers/ensure-cors-headers.ts",
            "name": "EnsureCORSFunction",
            "description": "",
            "members": [],
            "value": "export interface EnsureCORSFunction {\n  (response: Response): Response;\n}"
          },
          "EmbeddedAdminContext": {
            "filePath": "src/server/authenticate/admin/types.ts",
            "name": "EmbeddedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionToken",
                "value": "JwtPayload",
                "description": "The decoded and validated session token for the request.\n\nReturned only if `isEmbeddedApp` is `true`.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using the decoded session token",
                    "description": "Get user-specific data using the `sessionToken` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken } = await authenticate.admin(\n    request\n  );\n  return json(await getMyAppData({user: sessionToken.sub}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "redirect",
                "value": "RedirectFunction",
                "description": "A function that redirects the user to a new page, ensuring that the appropriate parameters are set for embedded apps.\n\nReturned only if `isEmbeddedApp` is `true`.",
                "examples": [
                  {
                    "title": "Redirecting to an app route",
                    "description": "Use the `redirect` helper to safely redirect between pages.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\");\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  },
                  {
                    "title": "Redirecting outside of Shopify admin",
                    "description": "Pass in a `target` option of `_top` or `_parent` to go to an external URL.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, redirect } = await authenticate.admin(request);\n  return redirect(\"/\", { target: '_parent' });\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the user who made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using offline sessions",
                    "description": "Get your app's shop-specific data using an offline session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Using online sessions",
                    "description": "Get your app's user-specific data using an online session.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session } = await authenticate.admin(request);\n  return json(await getMyAppData({user: session.onlineAccessInfo!.id}));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  useOnlineTokens: true,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request."
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingContext<Config>",
                "description": "Billing methods for this store, based on the plans defined in the `billing` config option.\n\n\n\n\n"
              },
              {
                "filePath": "src/server/authenticate/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a admin request",
                    "description": "Use the `cors` helper to ensure your app can respond to requests from admin extensions.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { session, cors } = await authenticate.admin(request);\n  return cors(json(await getMyAppData({user: session.onlineAccessInfo!.id})));\n};",
                        "title": "/app/routes/admin/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface EmbeddedAdminContext<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends AdminContextInternal<Config, Resources> {\n  /**\n   * The decoded and validated session token for the request.\n   *\n   * Returned only if `isEmbeddedApp` is `true`.\n   *\n   * {@link https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload}\n   *\n   * @example\n   * <caption>Using the decoded session token.</caption>\n   * <description>Get user-specific data using the `sessionToken` object.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken } = await authenticate.admin(\n   *     request\n   *   );\n   *   return json(await getMyAppData({user: sessionToken.sub}));\n   * };\n   * ```\n   * ```ts\n   * // shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   useOnlineTokens: true,\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  sessionToken: JwtPayload;\n\n  /**\n   * A function that redirects the user to a new page, ensuring that the appropriate parameters are set for embedded\n   * apps.\n   *\n   * Returned only if `isEmbeddedApp` is `true`.\n   *\n   * @example\n   * <caption>Redirecting to an app route.</caption>\n   * <description>Use the `redirect` helper to safely redirect between pages.</description>\n   * ```ts\n   * // /app/routes/admin/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { session, redirect } = await authenticate.admin(request);\n   *   return redirect(\"/\");\n   * };\n   * ```\n   *\n   * @example\n   * <caption>Redirecting outside of Shopify admin.</caption>\n   * <description>Pass in a `target` option of `_top` or `_parent` to go to an external URL.</description>\n   * ```ts\n   * // /app/routes/admin/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { session, redirect } = await authenticate.admin(request);\n   *   return redirect(\"/\", { target: '_parent' });\n   * };\n   * ```\n   */\n  redirect: RedirectFunction;\n}"
          },
          "JwtPayload": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "JwtPayload",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iss",
                "value": "string",
                "description": "The shop's admin domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "dest",
                "value": "string",
                "description": "The shop's domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "aud",
                "value": "string",
                "description": "The client ID of the receiving app."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sub",
                "value": "string",
                "description": "The User that the session token is intended for."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "exp",
                "value": "number",
                "description": "When the session token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nbf",
                "value": "number",
                "description": "When the session token activates."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "iat",
                "value": "number",
                "description": "When the session token was issued."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "jti",
                "value": "string",
                "description": "A secure random UUID."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sid",
                "value": "string",
                "description": "A unique session ID per user and app."
              }
            ],
            "value": "export interface JwtPayload {\n  /**\n   * The shop's admin domain.\n   */\n  iss: string;\n  /**\n   * The shop's domain.\n   */\n  dest: string;\n  /**\n   * The client ID of the receiving app.\n   */\n  aud: string;\n  /**\n   * The User that the session token is intended for.\n   */\n  sub: string;\n  /**\n   * When the session token expires.\n   */\n  exp: number;\n  /**\n   * When the session token activates.\n   */\n  nbf: number;\n  /**\n   * When the session token was issued.\n   */\n  iat: number;\n  /**\n   * A secure random UUID.\n   */\n  jti: string;\n  /**\n   * A unique session ID per user and app.\n   */\n  sid: string;\n}"
          },
          "RedirectFunction": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "name": "RedirectFunction",
            "description": "",
            "params": [
              {
                "name": "url",
                "description": "",
                "value": "string",
                "filePath": "src/server/authenticate/admin/helpers/redirect.ts"
              },
              {
                "name": "init",
                "description": "",
                "value": "RedirectInit",
                "isOptional": true,
                "filePath": "src/server/authenticate/admin/helpers/redirect.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
              "description": "",
              "name": "TypedResponse<never>",
              "value": "TypedResponse<never>"
            },
            "value": "export type RedirectFunction = (\n  url: string,\n  init?: RedirectInit,\n) => TypedResponse<never>;"
          },
          "RedirectInit": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RedirectInit",
            "value": "number | (ResponseInit & {target?: RedirectTarget})",
            "description": ""
          },
          "RedirectTarget": {
            "filePath": "src/server/authenticate/admin/helpers/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RedirectTarget",
            "value": "'_self' | '_parent' | '_top'",
            "description": ""
          },
          "RestResourcesType": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestResourcesType",
            "value": "Config['restResources'] extends ShopifyRestResources\n    ? Config['restResources']\n    : ShopifyRestResources",
            "description": ""
          },
          "ShopifyRestResources": {
            "filePath": "../shopify-api/rest/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyRestResources",
            "value": "Record<string, any>",
            "description": "",
            "members": []
          },
          "AuthenticateFlow": {
            "filePath": "src/server/authenticate/flow/types.ts",
            "name": "AuthenticateFlow",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/flow/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/flow/types.ts",
              "description": "",
              "name": "Promise<FlowContext<Resources>>",
              "value": "Promise<FlowContext<Resources>>"
            },
            "value": "export type AuthenticateFlow<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> = (request: Request) => Promise<FlowContext<Resources>>;"
          },
          "FlowContext": {
            "filePath": "src/server/authenticate/flow/types.ts",
            "name": "FlowContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/flow/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "A session with an offline token for the shop.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Shopify session for the Flow request",
                    "description": "Use the session associated with this request to use REST resources.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { session, admin } = await authenticate.flow(request);\n\n  const products = await admin?.rest.resources.Product.all({ session });\n  // Use products\n\n  return new Response();\n};",
                        "title": "/app/routes/flow.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/flow/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "any",
                "description": "The payload from the Flow request.",
                "examples": [
                  {
                    "title": "Flow payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { payload } = await authenticate.flow(request);\n  return new Response();\n};",
                        "title": "/app/routes/flow.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/flow/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "An admin context for the Flow request.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Flow admin context",
                    "description": "Use the `admin` object in the context to interact with the Admin API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.flow(request);\n\n  const response = await admin?.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/flow.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface FlowContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * A session with an offline token for the shop.\n   *\n   * Returned only if there is a session for the shop.\n   *\n   * @example\n   * <caption>Shopify session for the Flow request.</caption>\n   * <description>Use the session associated with this request to use REST resources.</description>\n   * ```ts\n   * // /app/routes/flow.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { session, admin } = await authenticate.flow(request);\n   *\n   *   const products = await admin?.rest.resources.Product.all({ session });\n   *   // Use products\n   *\n   *   return new Response();\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * The payload from the Flow request.\n   *\n   * @example\n   * <caption>Flow payload.</caption>\n   * <description>Get the request's POST payload.</description>\n   * ```ts\n   * // /app/routes/flow.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { payload } = await authenticate.flow(request);\n   *   return new Response();\n   * };\n   * ```\n   */\n  payload: any;\n\n  /**\n   * An admin context for the Flow request.\n   *\n   * Returned only if there is a session for the shop.\n   *\n   * @example\n   * <caption>Flow admin context.</caption>\n   * <description>Use the `admin` object in the context to interact with the Admin API.</description>\n   * ```ts\n   * // /app/routes/flow.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.flow(request);\n   *\n   *   const response = await admin?.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     { variables: { input: { title: \"Product Name\" } } }\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n}"
          },
          "AuthenticateFulfillmentService": {
            "filePath": "src/server/authenticate/fulfillment-service/types.ts",
            "name": "AuthenticateFulfillmentService",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/fulfillment-service/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/fulfillment-service/types.ts",
              "description": "",
              "name": "Promise<FulfillmentServiceContext<Resources>>",
              "value": "Promise<FulfillmentServiceContext<Resources>>"
            },
            "value": "export type AuthenticateFulfillmentService<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> = (request: Request) => Promise<FulfillmentServiceContext<Resources>>;"
          },
          "FulfillmentServiceContext": {
            "filePath": "src/server/authenticate/fulfillment-service/types.ts",
            "name": "FulfillmentServiceContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/fulfillment-service/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "A session with an offline token for the shop.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Shopify session for the fulfillment service notification request",
                    "description": "Use the session associated with this request to use REST resources.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\n  export const action = async ({ request }: ActionFunctionArgs) => {\n  const { session, admin } = await authenticate.fulfillmentService(request);\n\n  const products = await admin?.rest.resources.Product.all({ session });\n  // Use products\n\n  return new Response();\n};",
                        "title": "/app/routes/fulfillment_service_notification.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/fulfillment-service/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "\nAn admin context for the fulfillment service request.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "Shopify session for the fulfillment service request",
                    "description": "Use the session associated with this request to use the Admin GraphQL API",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.fulfillmentService(request);\n  const response = await admin?.graphql(\n `#graphql\n   query {\n     shop {\n       assignedFulfillmentOrders(first: 10, assignmentStatus: FULFILLMENT_REQUESTED) {\n         edges {\n           node {\n             id\n             destination {\n             firstName\n             lastName\n           }\n           lineItems(first: 10) {\n             edges {\n               node {\n               id\n               productTitle\n               sku\n               remainingQuantity\n             }\n           }\n         }\n         merchantRequests(first: 10, kind: FULFILLMENT_REQUEST) {\n           edges {\n             node {\n               message\n             }\n           }\n         }\n       }\n     }\n   }\n }\n}`);\n\n  const fulfillments = await response.json();\n  return json({ data: fulfillments.data });\n}",
                        "title": "/app/routes/fulfillment_order_notification.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/fulfillment-service/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "Record<string, any> & { kind: string; }",
                "description": "The payload from the fulfillment service request.",
                "examples": [
                  {
                    "title": "Fulfillment service request payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "/app/routes/fulfillment_order_notification.ts\nimport { ActionFunction } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action: ActionFunction = async ({ request }) => {\n  const { payload } = await authenticate.fulfillmentService(request);\n  if(payload.kind === 'FULFILLMENT_REQUEST') {\n   // handle fulfillment request\n  } else if (payload.kind === 'CANCELLATION_REQUEST') {\n   // handle cancellation request\n  };\nreturn new Response();",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface FulfillmentServiceContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * A session with an offline token for the shop.\n   *\n   * Returned only if there is a session for the shop.\n   * @example\n   * <caption>Shopify session for the fulfillment service notification request.</caption>\n   * <description>Use the session associated with this request to use REST resources.</description>\n   * ```ts\n   * // /app/routes/fulfillment_service_notification.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   *   export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { session, admin } = await authenticate.fulfillmentService(request);\n   *\n   *   const products = await admin?.rest.resources.Product.all({ session });\n   *   // Use products\n   *\n   *   return new Response();\n   * };\n   * ```\n   * */\n  session: Session;\n  /**\n   *\n   * An admin context for the fulfillment service request.\n   *\n   * Returned only if there is a session for the shop.\n   * @example\n   * <caption>Shopify session for the fulfillment service request.</caption>\n   * <description>Use the session associated with this request to use the Admin GraphQL API </description>\n   * ```ts\n   * // /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.fulfillmentService(request);\n   *   const response = await admin?.graphql(\n   *  `#graphql\n   *    query {\n   *      shop {\n   *        assignedFulfillmentOrders(first: 10, assignmentStatus: FULFILLMENT_REQUESTED) {\n   *          edges {\n   *            node {\n   *              id\n   *              destination {\n   *              firstName\n   *              lastName\n   *            }\n   *            lineItems(first: 10) {\n   *              edges {\n   *                node {\n   *                id\n   *                productTitle\n   *                sku\n   *                remainingQuantity\n   *              }\n   *            }\n   *          }\n   *          merchantRequests(first: 10, kind: FULFILLMENT_REQUEST) {\n   *            edges {\n   *              node {\n   *                message\n   *              }\n   *            }\n   *          }\n   *        }\n   *      }\n   *    }\n   *  }\n   * }`);\n   *\n   *   const fulfillments = await response.json();\n   *   return json({ data: fulfillments.data });\n   * }\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n\n  /**\n   * The payload from the fulfillment service request.\n   *\n   * @example\n   * <caption>Fulfillment service request payload.</caption>\n   * <description>Get the request's POST payload.</description>\n   * ```ts\n   * /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunction } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action: ActionFunction = async ({ request }) => {\n   *   const { payload } = await authenticate.fulfillmentService(request);\n   *   if(payload.kind === 'FULFILLMENT_REQUEST') {\n   *    // handle fulfillment request\n   *   } else if (payload.kind === 'CANCELLATION_REQUEST') {\n   *    // handle cancellation request\n   *   };\n   * return new Response();\n   * ```\n   */\n  payload: Record<string, any> & {\n    kind: string;\n  };\n}"
          },
          "AuthenticatePublic": {
            "filePath": "src/server/authenticate/public/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AuthenticatePublic",
            "value": "FeatureEnabled<Future, 'v3_authenticatePublic'> extends true\n    ? AuthenticatePublicObject\n    : AuthenticatePublicLegacy",
            "description": ""
          },
          "AuthenticatePublicObject": {
            "filePath": "src/server/authenticate/public/types.ts",
            "name": "AuthenticatePublicObject",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "checkout",
                "value": "AuthenticateCheckout",
                "description": "Authenticate a request from a checkout extension",
                "examples": [
                  {
                    "title": "Authenticating a checkout extension request",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken, cors } = await authenticate.public.checkout(\n    request,\n  );\n  return cors(json({my: \"data\", shop: sessionToken.dest}));\n};",
                        "title": "/app/routes/public/widgets.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "appProxy",
                "value": "AuthenticateAppProxy",
                "description": "Authenticate a request from an app proxy",
                "examples": [
                  {
                    "title": "Authenticating an app proxy request",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  await authenticate.public.appProxy(\n    request,\n  );\n\n  const {searchParams} = new URL(request.url);\n  const shop = searchParams.get(\"shop\");\n  const customerId = searchParams.get(\"logged_in_customer_id\")\n\n  return json({my: \"data\", shop, customerId});\n};",
                        "title": "/app/routes/public/widgets.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AuthenticatePublicObject {\n  /**\n   * Authenticate a request from a checkout extension\n   *\n   * @example\n   * <caption>Authenticating a checkout extension request</caption>\n   * ```ts\n   * // /app/routes/public/widgets.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken, cors } = await authenticate.public.checkout(\n   *     request,\n   *   );\n   *   return cors(json({my: \"data\", shop: sessionToken.dest}));\n   * };\n   * ```\n   */\n  checkout: AuthenticateCheckout;\n\n  /**\n   * Authenticate a request from an app proxy\n   *\n   * @example\n   * <caption>Authenticating an app proxy request</caption>\n   * ```ts\n   * // /app/routes/public/widgets.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   await authenticate.public.appProxy(\n   *     request,\n   *   );\n   *\n   *   const {searchParams} = new URL(request.url);\n   *   const shop = searchParams.get(\"shop\");\n   *   const customerId = searchParams.get(\"logged_in_customer_id\")\n   *\n   *   return json({my: \"data\", shop, customerId});\n   * };\n   * ```\n   */\n  appProxy: AuthenticateAppProxy;\n}"
          },
          "AuthenticateCheckout": {
            "filePath": "src/server/authenticate/public/checkout/types.ts",
            "name": "AuthenticateCheckout",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/public/checkout/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "AuthenticateCheckoutOptions",
                "isOptional": true,
                "filePath": "src/server/authenticate/public/checkout/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/public/checkout/types.ts",
              "description": "",
              "name": "Promise<CheckoutContext>",
              "value": "Promise<CheckoutContext>"
            },
            "value": "export type AuthenticateCheckout = (\n  request: Request,\n  options?: AuthenticateCheckoutOptions,\n) => Promise<CheckoutContext>;"
          },
          "AuthenticateCheckoutOptions": {
            "filePath": "src/server/authenticate/public/checkout/types.ts",
            "name": "AuthenticateCheckoutOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/checkout/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "corsHeaders",
                "value": "string[]",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface AuthenticateCheckoutOptions {\n  corsHeaders?: string[];\n}"
          },
          "CheckoutContext": {
            "filePath": "src/server/authenticate/public/checkout/types.ts",
            "name": "CheckoutContext",
            "description": "Authenticated Context for a checkout request",
            "members": [
              {
                "filePath": "src/server/authenticate/public/checkout/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionToken",
                "value": "JwtPayload",
                "description": "The decoded and validated session token for the request\n\nRefer to the OAuth docs for the [session token payload](https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload).",
                "examples": [
                  {
                    "title": "Using the decoded session token",
                    "description": "Get store-specific data using the `sessionToken` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken } = await authenticate.public.checkout(\n    request\n  );\n  return json(await getMyAppData({shop: sessionToken.dest}));\n};",
                        "title": "app/routes/public/my-route.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/checkout/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cors",
                "value": "EnsureCORSFunction",
                "description": "A function that ensures the CORS headers are set correctly for the response.",
                "examples": [
                  {
                    "title": "Setting CORS headers for a public request",
                    "description": "Use the `cors` helper to ensure your app can respond to checkout extension requests.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const { sessionToken, cors } = await authenticate.public.checkout(\n    request,\n    { corsHeaders: [\"X-My-Custom-Header\"] }\n  );\n  const data = await getMyAppData({shop: sessionToken.dest});\n  return cors(json(data));\n};",
                        "title": "app/routes/public/my-route.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface CheckoutContext {\n  /**\n   * The decoded and validated session token for the request\n   *\n   * Refer to the OAuth docs for the [session token payload](https://shopify.dev/docs/apps/auth/oauth/session-tokens#payload).\n   *\n   * @example\n   * <caption>Using the decoded session token.</caption>\n   * <description>Get store-specific data using the `sessionToken` object.</description>\n   * ```ts\n   * // app/routes/public/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken } = await authenticate.public.checkout(\n   *     request\n   *   );\n   *   return json(await getMyAppData({shop: sessionToken.dest}));\n   * };\n   * ```\n   */\n  sessionToken: JwtPayload;\n\n  /**\n   * A function that ensures the CORS headers are set correctly for the response.\n   *\n   * @example\n   * <caption>Setting CORS headers for a public request.</caption>\n   * <description>Use the `cors` helper to ensure your app can respond to checkout extension requests.</description>\n   * ```ts\n   * // app/routes/public/my-route.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const { sessionToken, cors } = await authenticate.public.checkout(\n   *     request,\n   *     { corsHeaders: [\"X-My-Custom-Header\"] }\n   *   );\n   *   const data = await getMyAppData({shop: sessionToken.dest});\n   *   return cors(json(data));\n   * };\n   * ```\n   */\n  cors: EnsureCORSFunction;\n}"
          },
          "AuthenticateAppProxy": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "AuthenticateAppProxy",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/public/appProxy/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/public/appProxy/types.ts",
              "description": "",
              "name": "Promise<AppProxyContext | AppProxyContextWithSession>",
              "value": "Promise<AppProxyContext | AppProxyContextWithSession>"
            },
            "value": "export type AuthenticateAppProxy = (\n  request: Request,\n) => Promise<AppProxyContext | AppProxyContextWithSession>;"
          },
          "AppProxyContext": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "AppProxyContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "undefined",
                "description": "No session is available for the shop that made this request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice."
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "undefined",
                "description": "No session is available for the shop that made this request. Therefore no methods for interacting with the GraphQL / REST Admin APIs are available."
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "undefined",
                "description": "No session is available for the shop that made this request. Therefore no method for interacting with the Storefront API is available."
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "liquid",
                "value": "LiquidResponseFunction",
                "description": "A utility for creating a Liquid Response.",
                "examples": [
                  {
                    "title": "Rendering liquid content",
                    "description": "Use the `liquid` helper to render a `Response` with Liquid content using the shop's theme. See the [Liquid reference](https://shopify.dev/docs/api/liquid) for all the features it enables.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\"Hello {{shop.name}}\");\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering liquid content without a layout",
                    "description": "Set the `layout` option to `false` to render the Liquid content without a theme.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\n    \"Hello {{shop.name}}\",\n    { layout: false }\n  );\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering a form in a Liquid response",
                    "description": "Handle form submissions through an app proxy.",
                    "tabs": [
                      {
                        "code": "import { redirect } from \"@remix-run/node\";\nimport { authenticate } from \"~/shopify.server\";\n\nexport async function loader({ request }) {\n  const { liquid } = await authenticate.public.appProxy(request);\n\n  return liquid(`\n    <form method=\"post\" action=\"/apps/proxy/my-action\">\n      <input type=\"text\" name=\"field\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  `);\n}\n\nexport async function action({ request }) {\n  await authenticate.public.appProxy(request);\n\n  const formData = await request.formData();\n  const field = formData.get(\"field\")?.toString();\n\n  // Perform actions here\n  if (field) {\n    console.log(\"Field:\", field);\n  }\n\n  // Return to the form page\n  return redirect(\"/apps/proxy/my-action\");\n}",
                        "title": "app/routes/apps.proxy.my-action.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AppProxyContext extends Context {\n  /**\n   * No session is available for the shop that made this request.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   */\n  session: undefined;\n\n  /**\n   * No session is available for the shop that made this request.\n   * Therefore no methods for interacting with the GraphQL / REST Admin APIs are available.\n   */\n  admin: undefined;\n\n  /**\n   * No session is available for the shop that made this request.\n   * Therefore no method for interacting with the Storefront API is available.\n   */\n  storefront: undefined;\n}"
          },
          "LiquidResponseFunction": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "LiquidResponseFunction",
            "description": "",
            "params": [
              {
                "name": "body",
                "description": "",
                "value": "string",
                "filePath": "src/server/authenticate/public/appProxy/types.ts"
              },
              {
                "name": "initAndOptions",
                "description": "",
                "value": "number | (ResponseInit & Options)",
                "isOptional": true,
                "filePath": "src/server/authenticate/public/appProxy/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/public/appProxy/types.ts",
              "description": "",
              "name": "Response",
              "value": "Response"
            },
            "value": "export type LiquidResponseFunction = (\n  body: string,\n  initAndOptions?: number | (ResponseInit & Options),\n) => Response;"
          },
          "Options": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "Options",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "layout",
                "value": "boolean",
                "description": "Whether to use the shop's theme layout around the Liquid content.",
                "isOptional": true
              }
            ],
            "value": "interface Options {\n  /**\n   * Whether to use the shop's theme layout around the Liquid content.\n   */\n  layout?: boolean;\n}"
          },
          "AppProxyContextWithSession": {
            "filePath": "src/server/authenticate/public/appProxy/types.ts",
            "name": "AppProxyContextWithSession",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the shop that made the request.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nUse this to get shop or user-specific data.",
                "examples": [
                  {
                    "title": "Using the session object",
                    "description": "Get the session for the shop that initiated the request to the app proxy.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\nimport { getMyAppModelData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }) => {\n  // Get the session for the shop that initiated the request to the app proxy.\n  const { session } =\n    await authenticate.public.appProxy(request);\n\n  // Use the session data to make to queries to your database or additional requests.\n  return json(\n    await getMyAppModelData({shop: session.shop})\n  );\n};",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request.",
                "examples": [
                  {
                    "title": "Interacting with the Admin API",
                    "description": "Use the `admin` object to interact with the REST or GraphQL APIs.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.public.appProxy(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" }\n      }\n    }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "StorefrontContext",
                "description": "Method for interacting with the Shopify Storefront Graphql API for the store that made the request.",
                "examples": [
                  {
                    "title": "Interacting with the Storefront API",
                    "description": "Use the `storefront` object to interact with the GraphQL API.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(\n    `#graphql\n    query blogIds {\n      blogs(first: 10) {\n        edges {\n          node {\n            id\n          }\n        }\n      }\n    }`\n  );\n\n  return json(await response.json());\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/public/appProxy/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "liquid",
                "value": "LiquidResponseFunction",
                "description": "A utility for creating a Liquid Response.",
                "examples": [
                  {
                    "title": "Rendering liquid content",
                    "description": "Use the `liquid` helper to render a `Response` with Liquid content using the shop's theme. See the [Liquid reference](https://shopify.dev/docs/api/liquid) for all the features it enables.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\"Hello {{shop.name}}\");\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering liquid content without a layout",
                    "description": "Set the `layout` option to `false` to render the Liquid content without a theme.",
                    "tabs": [
                      {
                        "code": "import {authenticate} from \"~/shopify.server\"\n\nexport async function loader({ request }) {\n  const {liquid} = await authenticate.public.appProxy(request);\n\n  return liquid(\n    \"Hello {{shop.name}}\",\n    { layout: false }\n  );\n}",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  },
                  {
                    "title": "Rendering a form in a Liquid response",
                    "description": "Handle form submissions through an app proxy.",
                    "tabs": [
                      {
                        "code": "import { redirect } from \"@remix-run/node\";\nimport { authenticate } from \"~/shopify.server\";\n\nexport async function loader({ request }) {\n  const { liquid } = await authenticate.public.appProxy(request);\n\n  return liquid(`\n    <form method=\"post\" action=\"/apps/proxy/my-action\">\n      <input type=\"text\" name=\"field\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  `);\n}\n\nexport async function action({ request }) {\n  await authenticate.public.appProxy(request);\n\n  const formData = await request.formData();\n  const field = formData.get(\"field\")?.toString();\n\n  // Perform actions here\n  if (field) {\n    console.log(\"Field:\", field);\n  }\n\n  // Return to the form page\n  return redirect(\"/apps/proxy/my-action\");\n}",
                        "title": "app/routes/apps.proxy.my-action.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AppProxyContextWithSession<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> extends Context {\n  /**\n   * The session for the shop that made the request.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   *\n   * Use this to get shop or user-specific data.\n   *\n   * @example\n   * <caption>Using the session object.</caption>\n   * <description>Get the session for the shop that initiated the request to the app proxy.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import { getMyAppModelData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }) => {\n   *   // Get the session for the shop that initiated the request to the app proxy.\n   *   const { session } =\n   *     await authenticate.public.appProxy(request);\n   *\n   *   // Use the session data to make to queries to your database or additional requests.\n   *   return json(\n   *     await getMyAppModelData({shop: session.shop})\n   *   );\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * Methods for interacting with the GraphQL / REST Admin APIs for the store that made the request.\n   *\n   * @example\n   * <caption>Interacting with the Admin API.</caption>\n   * <description>Use the `admin` object to interact with the REST or GraphQL APIs.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" }\n   *       }\n   *     }\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n\n  /**\n   * Method for interacting with the Shopify Storefront Graphql API for the store that made the request.\n   *\n   * @example\n   * <caption>Interacting with the Storefront API.</caption>\n   * <description>Use the `storefront` object to interact with the GraphQL API.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await storefront.graphql(\n   *     `#graphql\n   *     query blogIds {\n   *       blogs(first: 10) {\n   *         edges {\n   *           node {\n   *             id\n   *           }\n   *         }\n   *       }\n   *     }`\n   *   );\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  storefront: StorefrontContext;\n}"
          },
          "StorefrontContext": {
            "filePath": "src/server/clients/storefront/types.ts",
            "name": "StorefrontContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<StorefrontOperations>",
                "description": "Method for interacting with the Shopify Storefront GraphQL API\n\nIf you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `storefront.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  try {\n    const response = await storefront.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // { errors: { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] } }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface StorefrontContext {\n  /**\n   * Method for interacting with the Shopify Storefront GraphQL API\n   *\n   * If you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n   *\n   * {@link https://shopify.dev/docs/api/storefront}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `storefront.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   try {\n   *     const response = await storefront.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // { errors: { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] } }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<StorefrontOperations>;\n}"
          },
          "AuthenticatePublicLegacy": {
            "filePath": "src/server/authenticate/public/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AuthenticatePublicLegacy",
            "value": "AuthenticateCheckout & AuthenticatePublicObject",
            "description": "Methods for authenticating Requests from Shopify's public surfaces\n\nTo maintain backwards compatability this is a function and an object.\n\nDo not use `authenticate.public()`. Use `authenticate.public.checkout()` instead. `authenticate.public()` will be removed in v2.\n\nMethods are:\n\n- `authenticate.public.checkout()` for authenticating requests from checkout extensions - `authenticate.public.appProxy()` for authenticating requests from app proxies"
          },
          "AuthenticateWebhook": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "AuthenticateWebhook",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/authenticate/webhooks/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/authenticate/webhooks/types.ts",
              "description": "",
              "name": "Promise<WebhookContext<Future, Resources, Topics>>",
              "value": "Promise<WebhookContext<Future, Resources, Topics>>"
            },
            "value": "export type AuthenticateWebhook<\n  Future extends FutureFlagOptions,\n  Resources extends ShopifyRestResources,\n  Topics = string | number | symbol,\n> = (request: Request) => Promise<WebhookContext<Future, Resources, Topics>>;"
          },
          "WebhookContext": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "WebhookContext",
            "value": "WebhookContextWithoutSession<Topics> | WebhookContextWithSession<Future, Resources, Topics>",
            "description": ""
          },
          "WebhookContextWithoutSession": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "WebhookContextWithoutSession",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "undefined",
                "description": ""
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "undefined",
                "description": ""
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "string",
                "description": "The API version used for the webhook.",
                "examples": [
                  {
                    "title": "Webhook API version",
                    "description": "Get the API version used for webhook request.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { apiVersion } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The shop where the webhook was triggered.",
                "examples": [
                  {
                    "title": "Webhook shop",
                    "description": "Get the shop that triggered a webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { shop } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "topic",
                "value": "Topics",
                "description": "The topic of the webhook.",
                "examples": [
                  {
                    "title": "Webhook topic",
                    "description": "Get the event topic for the webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { topic } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      // Do something when the app is uninstalled.\n      break;\n  }\n\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "webhookId",
                "value": "string",
                "description": "A unique ID for the webhook. Useful to keep track of which events your app has already processed.",
                "examples": [
                  {
                    "title": "Webhook ID",
                    "description": "Get the webhook ID.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { webhookId } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "Record<string, any>",
                "description": "The payload from the webhook request.",
                "examples": [
                  {
                    "title": "Webhook payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { payload } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subTopic",
                "value": "string",
                "description": "The sub-topic of the webhook. This is only available for certain webhooks.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Webhook sub-topic",
                    "description": "Get the webhook sub-topic.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { subTopic } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface WebhookContextWithoutSession<Topics = string | number | symbol>\n  extends Context<Topics> {\n  session: undefined;\n  admin: undefined;\n}"
          },
          "WebhookContextWithSession": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "WebhookContextWithSession",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "A session with an offline token for the shop.\n\nReturned only if there is a session for the shop."
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "WebhookAdminContext<Future, Resources>",
                "description": "An admin context for the webhook.\n\nReturned only if there is a session for the shop.",
                "examples": [
                  {
                    "title": "[V3] Webhook admin context",
                    "description": "With the `v3_webhookAdminContext` future flag enabled, use the `admin` object in the context to interact with the Admin API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.webhook(request);\n\n  const response = await admin?.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n  const productData = await response.json();\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  },
                  {
                    "title": "Webhook admin context",
                    "description": "Use the `admin` object in the context to interact with the Admin API. This format will be removed in V3 of the package.",
                    "tabs": [
                      {
                        "code": "import { json, ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { admin } = await authenticate.webhook(request);\n\n  const response = await admin?.graphql.query<any>({\n    data: {\n      query: `#graphql\n        mutation populateProduct($input: ProductInput!) {\n          productCreate(input: $input) {\n            product {\n              id\n            }\n          }\n        }`,\n      variables: { input: { title: \"Product Name\" } },\n    },\n  });\n\n  const productData = response?.body.data;\n  return json({ data: productData.data });\n}",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "string",
                "description": "The API version used for the webhook.",
                "examples": [
                  {
                    "title": "Webhook API version",
                    "description": "Get the API version used for webhook request.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { apiVersion } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The shop where the webhook was triggered.",
                "examples": [
                  {
                    "title": "Webhook shop",
                    "description": "Get the shop that triggered a webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { shop } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "topic",
                "value": "Topics",
                "description": "The topic of the webhook.",
                "examples": [
                  {
                    "title": "Webhook topic",
                    "description": "Get the event topic for the webhook.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { topic } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      // Do something when the app is uninstalled.\n      break;\n  }\n\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "webhookId",
                "value": "string",
                "description": "A unique ID for the webhook. Useful to keep track of which events your app has already processed.",
                "examples": [
                  {
                    "title": "Webhook ID",
                    "description": "Get the webhook ID.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { webhookId } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "Record<string, any>",
                "description": "The payload from the webhook request.",
                "examples": [
                  {
                    "title": "Webhook payload",
                    "description": "Get the request's POST payload.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { payload } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "subTopic",
                "value": "string",
                "description": "The sub-topic of the webhook. This is only available for certain webhooks.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Webhook sub-topic",
                    "description": "Get the webhook sub-topic.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { subTopic } = await authenticate.webhook(request);\n  return new Response();\n};",
                        "title": "/app/routes/webhooks.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface WebhookContextWithSession<\n  Future extends FutureFlagOptions,\n  Resources extends ShopifyRestResources,\n  Topics = string | number | symbol,\n> extends Context<Topics> {\n  /**\n   * A session with an offline token for the shop.\n   *\n   * Returned only if there is a session for the shop.\n   */\n  session: Session;\n\n  /**\n   * An admin context for the webhook.\n   *\n   * Returned only if there is a session for the shop.\n   *\n   * @example\n   * <caption>[V3] Webhook admin context.</caption>\n   * <description>With the `v3_webhookAdminContext` future flag enabled, use the `admin` object in the context to interact with the Admin API.</description>\n   * ```ts\n   * // /app/routes/webhooks.tsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.webhook(request);\n   *\n   *   const response = await admin?.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     { variables: { input: { title: \"Product Name\" } } }\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Webhook admin context.</caption>\n   * <description>Use the `admin` object in the context to interact with the Admin API. This format will be removed in V3 of the package.</description>\n   * ```ts\n   * // /app/routes/webhooks.tsx\n   * import { json, ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin } = await authenticate.webhook(request);\n   *\n   *   const response = await admin?.graphql.query<any>({\n   *     data: {\n   *       query: `#graphql\n   *         mutation populateProduct($input: ProductInput!) {\n   *           productCreate(input: $input) {\n   *             product {\n   *               id\n   *             }\n   *           }\n   *         }`,\n   *       variables: { input: { title: \"Product Name\" } },\n   *     },\n   *   });\n   *\n   *   const productData = response?.body.data;\n   *   return json({ data: productData.data });\n   * }\n   * ```\n   */\n  admin: WebhookAdminContext<Future, Resources>;\n}"
          },
          "WebhookAdminContext": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "WebhookAdminContext",
            "value": "FeatureEnabled<Future, 'v3_webhookAdminContext'> extends true\n    ? AdminApiContext<Resources>\n    : LegacyWebhookAdminApiContext<Resources>",
            "description": ""
          },
          "LegacyWebhookAdminApiContext": {
            "filePath": "src/server/authenticate/webhooks/types.ts",
            "name": "LegacyWebhookAdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClient & Resources",
                "description": "A REST client."
              },
              {
                "filePath": "src/server/authenticate/webhooks/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "InstanceType<Shopify['clients']['Graphql']>",
                "description": "A GraphQL client."
              }
            ],
            "value": "export interface LegacyWebhookAdminApiContext<\n  Resources extends ShopifyRestResources,\n> {\n  /** A REST client. */\n  rest: InstanceType<Shopify['clients']['Rest']> & Resources;\n  /** A GraphQL client. */\n  graphql: InstanceType<Shopify['clients']['Graphql']>;\n}"
          },
          "RestClient": {
            "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
            "name": "RestClient",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "loggedDeprecations",
                "value": "Record<string, number>",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "client",
                "value": "AdminRestApiClient",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "<T = any>(params: GetRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "<T = any>(params: PostRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "<T = any>(params: PostRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/rest/client.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "<T = any>(params: GetRequestParams) => Promise<RestRequestReturn<T>>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "export class RestClient {\n  public static config: ConfigInterface;\n  public static formatPaths: boolean;\n\n  static LINK_HEADER_REGEXP = /<([^<]+)>; rel=\"([^\"]+)\"/;\n  static DEFAULT_LIMIT = '50';\n  static RETRY_WAIT_TIME = 1000;\n\n  static readonly DEPRECATION_ALERT_DELAY = 300000;\n  loggedDeprecations: Record<string, number> = {};\n\n  readonly client: AdminRestApiClient;\n  readonly session: Session;\n  readonly apiVersion: ApiVersion;\n\n  public constructor({session, apiVersion}: RestClientParams) {\n    const config = this.restClass().config;\n\n    if (!config.isCustomStoreApp && !session.accessToken) {\n      throw new ShopifyErrors.MissingRequiredArgument(\n        'Missing access token when creating REST client',\n      );\n    }\n\n    if (apiVersion) {\n      const message =\n        apiVersion === config.apiVersion\n          ? `REST client has a redundant API version override to the default ${apiVersion}`\n          : `REST client overriding default API version ${config.apiVersion} with ${apiVersion}`;\n\n      logger(config).debug(message);\n    }\n\n    const customStoreAppAccessToken =\n      config.adminApiAccessToken ?? config.apiSecretKey;\n\n    this.session = session;\n    this.apiVersion = apiVersion ?? config.apiVersion;\n    this.client = createAdminRestApiClient({\n      scheme: config.hostScheme,\n      storeDomain: session.shop,\n      apiVersion: apiVersion ?? config.apiVersion,\n      accessToken: config.isCustomStoreApp\n        ? customStoreAppAccessToken\n        : session.accessToken!,\n      customFetchApi: abstractFetch,\n      logger: clientLoggerFactory(config),\n      userAgentPrefix: getUserAgent(config),\n      defaultRetryTime: this.restClass().RETRY_WAIT_TIME,\n      formatPaths: this.restClass().formatPaths,\n    });\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get<T = any>(params: GetRequestParams) {\n    return this.request<T>({method: Method.Get, ...params});\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post<T = any>(params: PostRequestParams) {\n    return this.request<T>({method: Method.Post, ...params});\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put<T = any>(params: PutRequestParams) {\n    return this.request<T>({method: Method.Put, ...params});\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete<T = any>(params: DeleteRequestParams) {\n    return this.request<T>({method: Method.Delete, ...params});\n  }\n\n  protected async request<T = any>(\n    params: RequestParams,\n  ): Promise<RestRequestReturn<T>> {\n    const requestParams = {\n      headers: {\n        ...params.extraHeaders,\n        ...(params.type ? {'Content-Type': params.type.toString()} : {}),\n      },\n      retries: params.tries ? params.tries - 1 : undefined,\n      searchParams: params.query,\n    };\n\n    let response: Response;\n    switch (params.method) {\n      case Method.Get:\n        response = await this.client.get(params.path, requestParams);\n        break;\n      case Method.Put:\n        response = await this.client.put(params.path, {\n          ...requestParams,\n          data: params.data!,\n        });\n        break;\n      case Method.Post:\n        response = await this.client.post(params.path, {\n          ...requestParams,\n          data: params.data!,\n        });\n        break;\n      case Method.Delete:\n        response = await this.client.delete(params.path, requestParams);\n        break;\n      default:\n        throw new ShopifyErrors.InvalidRequestError(\n          `Unsupported request method '${params.method}'`,\n        );\n    }\n\n    const body: any = await response.json();\n    const responseHeaders = canonicalizeHeaders(\n      Object.fromEntries(response.headers.entries()),\n    );\n\n    if (!response.ok) {\n      throwFailedRequest(body, (params.tries ?? 1) > 1, response);\n    }\n\n    const requestReturn: RestRequestReturn<T> = {\n      body,\n      headers: responseHeaders,\n    };\n\n    await this.logDeprecations(\n      {\n        method: params.method,\n        url: params.path,\n        headers: requestParams.headers,\n        body: params.data ? JSON.stringify(params.data) : undefined,\n      },\n      requestReturn,\n    );\n\n    const link = response.headers.get('Link');\n    if (link !== undefined) {\n      const pageInfo: PageInfo = {\n        limit: params.query?.limit\n          ? params.query?.limit.toString()\n          : RestClient.DEFAULT_LIMIT,\n      };\n\n      if (link) {\n        const links = link.split(', ');\n\n        for (const link of links) {\n          const parsedLink = link.match(RestClient.LINK_HEADER_REGEXP);\n          if (!parsedLink) {\n            continue;\n          }\n\n          const linkRel = parsedLink[2];\n          const linkUrl = new URL(parsedLink[1]);\n          const linkFields = linkUrl.searchParams.get('fields');\n          const linkPageToken = linkUrl.searchParams.get('page_info');\n\n          if (!pageInfo.fields && linkFields) {\n            pageInfo.fields = linkFields.split(',');\n          }\n\n          if (linkPageToken) {\n            switch (linkRel) {\n              case 'previous':\n                pageInfo.previousPageUrl = parsedLink[1];\n                pageInfo.prevPage = this.buildRequestParams(parsedLink[1]);\n                break;\n              case 'next':\n                pageInfo.nextPageUrl = parsedLink[1];\n                pageInfo.nextPage = this.buildRequestParams(parsedLink[1]);\n                break;\n            }\n          }\n        }\n      }\n\n      requestReturn.pageInfo = pageInfo;\n    }\n\n    return requestReturn;\n  }\n\n  private restClass() {\n    return this.constructor as typeof RestClient;\n  }\n\n  private buildRequestParams(newPageUrl: string): PageInfoParams {\n    const pattern = `^/admin/api/[^/]+/(.*).json$`;\n\n    const url = new URL(newPageUrl);\n    const path = url.pathname.replace(new RegExp(pattern), '$1');\n    return {\n      path,\n      query: Object.fromEntries(url.searchParams.entries()),\n    };\n  }\n\n  private async logDeprecations(\n    request: NormalizedRequest,\n    response: RestRequestReturn,\n  ) {\n    const config = this.restClass().config;\n\n    const deprecationReason = getHeader(\n      response.headers,\n      'X-Shopify-API-Deprecated-Reason',\n    );\n    if (deprecationReason) {\n      const deprecation: DeprecationInterface = {\n        message: deprecationReason,\n        path: request.url,\n      };\n\n      if (request.body) {\n        // This can only be a string, since we're always converting the body before calling this method\n        deprecation.body = `${(request.body as string).substring(0, 100)}...`;\n      }\n\n      const depHash = await createSHA256HMAC(\n        config.apiSecretKey,\n        JSON.stringify(deprecation),\n        HashFormat.Hex,\n      );\n\n      if (\n        !Object.keys(this.loggedDeprecations).includes(depHash) ||\n        Date.now() - this.loggedDeprecations[depHash] >=\n          RestClient.DEPRECATION_ALERT_DELAY\n      ) {\n        this.loggedDeprecations[depHash] = Date.now();\n\n        const stack = new Error().stack;\n        const message = `API Deprecation Notice ${new Date().toLocaleString()} : ${JSON.stringify(\n          deprecation,\n        )}  -  Stack Trace: ${stack}`;\n        await logger(config).warning(message);\n      }\n    }\n  }\n}"
          },
          "RestRequestReturn": {
            "filePath": "../shopify-api/lib/clients/admin/types.ts",
            "name": "RestRequestReturn",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "body",
                "value": "T",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Headers",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pageInfo",
                "value": "PageInfo",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface RestRequestReturn<T = any> {\n  body: T;\n  headers: Headers;\n  pageInfo?: PageInfo;\n}"
          },
          "PageInfo": {
            "filePath": "../shopify-api/lib/clients/admin/types.ts",
            "name": "PageInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "limit",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "fields",
                "value": "string[]",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "previousPageUrl",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nextPageUrl",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "prevPage",
                "value": "PageInfoParams",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "nextPage",
                "value": "PageInfoParams",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface PageInfo {\n  limit: string;\n  fields?: string[];\n  previousPageUrl?: string;\n  nextPageUrl?: string;\n  prevPage?: PageInfoParams;\n  nextPage?: PageInfoParams;\n}"
          },
          "PageInfoParams": {
            "filePath": "../shopify-api/lib/clients/admin/types.ts",
            "name": "PageInfoParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "../shopify-api/lib/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": ""
              }
            ],
            "value": "export interface PageInfoParams {\n  path: string;\n  query: SearchParams;\n}"
          },
          "MandatoryTopics": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "MandatoryTopics",
            "value": "'CUSTOMERS_DATA_REQUEST' | 'CUSTOMERS_REDACT' | 'SHOP_REDACT'",
            "description": ""
          },
          "Unauthenticated": {
            "filePath": "src/server/unauthenticated/types.ts",
            "name": "Unauthenticated",
            "description": "",
            "members": [
              {
                "filePath": "src/server/unauthenticated/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "GetUnauthenticatedAdminContext<Resources>",
                "description": "Get an admin context by passing a shop\n\n**Warning** This should only be used for Requests that do not originate from Shopify. You must do your own authentication before using this method. This method throws an error if there is no session for the shop.",
                "examples": [
                  {
                    "title": "Responding to a request not controlled by Shopify",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticateExternal } from \"~/helpers/authenticate\"\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const shop = await authenticateExternal(request)\n  const {admin} = await shopify.unauthenticated.admin(shop);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/unauthenticated/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "GetUnauthenticatedStorefrontContext",
                "description": "Get a storefront context by passing a shop\n\n**Warning** This should only be used for Requests that do not originate from Shopify. You must do your own authentication before using this method. This method throws an error if there is no session for the shop.",
                "examples": [
                  {
                    "title": "Responding to a request not controlled by Shopify",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticateExternal } from \"~/helpers/authenticate\"\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const shop = await authenticateExternal(request)\n  const {storefront} = await shopify.unauthenticated.storefront(shop);\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface Unauthenticated<Resources extends ShopifyRestResources> {\n  /**\n   * Get an admin context by passing a shop\n   *\n   * **Warning** This should only be used for Requests that do not originate from Shopify.\n   * You must do your own authentication before using this method.\n   * This method throws an error if there is no session for the shop.\n   *\n   * @example\n   * <caption>Responding to a request not controlled by Shopify.</caption>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticateExternal } from \"~/helpers/authenticate\"\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const shop = await authenticateExternal(request)\n   *   const {admin} = await shopify.unauthenticated.admin(shop);\n   *\n   *   return json(await admin.rest.resources.Product.count({ session }));\n   * }\n   * ```\n   */\n  admin: GetUnauthenticatedAdminContext<Resources>;\n\n  /**\n   * Get a storefront context by passing a shop\n   *\n   * **Warning** This should only be used for Requests that do not originate from Shopify.\n   * You must do your own authentication before using this method.\n   * This method throws an error if there is no session for the shop.\n   *\n   * @example\n   * <caption>Responding to a request not controlled by Shopify</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticateExternal } from \"~/helpers/authenticate\"\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const shop = await authenticateExternal(request)\n   *   const {storefront} = await shopify.unauthenticated.storefront(shop);\n   *   const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  storefront: GetUnauthenticatedStorefrontContext;\n}"
          },
          "GetUnauthenticatedAdminContext": {
            "filePath": "src/server/unauthenticated/admin/types.ts",
            "name": "GetUnauthenticatedAdminContext",
            "description": "",
            "params": [
              {
                "name": "shop",
                "description": "",
                "value": "string",
                "filePath": "src/server/unauthenticated/admin/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/unauthenticated/admin/types.ts",
              "description": "",
              "name": "Promise<UnauthenticatedAdminContext<Resources>>",
              "value": "Promise<UnauthenticatedAdminContext<Resources>>"
            },
            "value": "export type GetUnauthenticatedAdminContext<\n  Resources extends ShopifyRestResources,\n> = (shop: string) => Promise<UnauthenticatedAdminContext<Resources>>;"
          },
          "UnauthenticatedAdminContext": {
            "filePath": "src/server/unauthenticated/admin/types.ts",
            "name": "UnauthenticatedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/unauthenticated/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the given shop.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nThis will always be an offline session. You can use to get shop-specific data.",
                "examples": [
                  {
                    "title": "Using the offline session",
                    "description": "Get your app's shop-specific data using the returned offline `session` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const shop = getShopFromExternalRequest(request);\n  const { session } = await unauthenticated.admin(shop);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/unauthenticated/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the given store.",
                "examples": [
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n const { admin, session } = await unauthenticated.admin(request);\n\n const response = await admin.rest.get(\n   {\n     path: \"/customers/count.json\"\n   }\n );\n const customers = await response.json();\n\n return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n restResources,\n // ...etc\n});\n\nexport default shopify;\nexport const unauthenticated = shopify.unauthenticated;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n const { admin } = await unauthenticated.admin(request);\n\n const response = await admin.graphql(\n   `#graphql\n   mutation populateProduct($input: ProductInput!) {\n     productCreate(input: $input) {\n       product {\n         id\n       }\n     }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n const productData = await response.json();\n return json({ data: productData.data });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n restResources,\n // ...etc\n});\nexport default shopify;\nexport const unauthenticated = shopify.unauthenticated;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface UnauthenticatedAdminContext<\n  Resources extends ShopifyRestResources,\n> {\n  /**\n   * The session for the given shop.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   *\n   * This will always be an offline session. You can use to get shop-specific data.\n   *\n   * @example\n   * <caption>Using the offline session.</caption>\n   * <description>Get your app's shop-specific data using the returned offline `session` object.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const shop = getShopFromExternalRequest(request);\n   *   const { session } = await unauthenticated.admin(shop);\n   *   return json(await getMyAppData({shop: session.shop));\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * Methods for interacting with the GraphQL / REST Admin APIs for the given store.\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *  const { admin, session } = await unauthenticated.admin(request);\n   *\n   *  const response = await admin.rest.get(\n   *    {\n   *      path: \"/customers/count.json\"\n   *    }\n   *  );\n   *  const customers = await response.json();\n   *\n   *  return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *  restResources,\n   *  // ...etc\n   * });\n   *\n   * export default shopify;\n   * export const unauthenticated = shopify.unauthenticated;\n   * ```\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *  const { admin } = await unauthenticated.admin(request);\n   *\n   *  const response = await admin.graphql(\n   *    `#graphql\n   *    mutation populateProduct($input: ProductInput!) {\n   *      productCreate(input: $input) {\n   *        product {\n   *          id\n   *        }\n   *      }\n   *     }`,\n   *     { variables: { input: { title: \"Product Name\" } } }\n   *   );\n   *\n   *  const productData = await response.json();\n   *  return json({ data: productData.data });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *  restResources,\n   *  // ...etc\n   * });\n   * export default shopify;\n   * export const unauthenticated = shopify.unauthenticated;\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n}"
          },
          "GetUnauthenticatedStorefrontContext": {
            "filePath": "src/server/unauthenticated/storefront/types.ts",
            "name": "GetUnauthenticatedStorefrontContext",
            "description": "",
            "params": [
              {
                "name": "shop",
                "description": "",
                "value": "string",
                "filePath": "src/server/unauthenticated/storefront/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/unauthenticated/storefront/types.ts",
              "description": "",
              "name": "Promise<UnauthenticatedStorefrontContext>",
              "value": "Promise<UnauthenticatedStorefrontContext>"
            },
            "value": "export type GetUnauthenticatedStorefrontContext = (\n  shop: string,\n) => Promise<UnauthenticatedStorefrontContext>;"
          },
          "UnauthenticatedStorefrontContext": {
            "filePath": "src/server/unauthenticated/storefront/types.ts",
            "name": "UnauthenticatedStorefrontContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/unauthenticated/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the given shop.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nThis will always be an offline session. You can use this to get shop specific data.",
                "examples": [
                  {
                    "title": "Using the offline session",
                    "description": "Get your app's shop-specific data using the returned offline `session` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const shop = getShopFromExternalRequest(request);\n  const { session } = await unauthenticated.storefront(shop);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/unauthenticated/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "StorefrontContext",
                "description": "Method for interacting with the Shopify GraphQL Storefront API for the given store."
              }
            ],
            "value": "export interface UnauthenticatedStorefrontContext {\n  /**\n   * The session for the given shop.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   *\n   * This will always be an offline session. You can use this to get shop specific data.\n   *\n   * @example\n   * <caption>Using the offline session.</caption>\n   * <description>Get your app's shop-specific data using the returned offline `session` object.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const shop = getShopFromExternalRequest(request);\n   *   const { session } = await unauthenticated.storefront(shop);\n   *   return json(await getMyAppData({shop: session.shop));\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * Method for interacting with the Shopify GraphQL Storefront API for the given store.\n   */\n  storefront: StorefrontContext;\n}"
          },
          "SingleMerchantApp": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SingleMerchantApp",
            "value": "ShopifyAppBase<Config> & ShopifyAppLogin",
            "description": ""
          },
          "ShopifyAppBase": {
            "filePath": "src/server/types.ts",
            "name": "ShopifyAppBase",
            "description": "",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionStorage",
                "value": "SessionStorageType<Config>",
                "description": "The `SessionStorage` instance you passed in as a config option.",
                "examples": [
                  {
                    "title": "Storing sessions with Prisma",
                    "description": "Import the `@shopify/shopify-app-session-storage-prisma` package to store sessions in your Prisma database.",
                    "tabs": [
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\nimport prisma from \"~/db.server\";\n\nconst shopify = shopifyApp({\n  sessionStorage: new PrismaSessionStorage(prisma),\n  // ...etc\n})\n\n// shopify.sessionStorage is an instance of PrismaSessionStorage",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "addDocumentResponseHeaders",
                "value": "AddDocumentResponseHeaders",
                "description": "Adds the required Content Security Policy headers for Shopify apps to the given Headers object.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Return headers on all requests",
                    "description": "Add headers to all HTML requests by calling `shopify.addDocumentResponseHeaders` in `entry.server.tsx`.",
                    "tabs": [
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const addDocumentResponseheaders = shopify.addDocumentResponseheaders;",
                        "title": "~/shopify.server.ts"
                      },
                      {
                        "code": "import { addDocumentResponseHeaders } from \"~/shopify.server\";\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  const markup = renderToString(\n    <RemixServer context={remixContext} url={request.url} />\n  );\n\n  responseHeaders.set(\"Content-Type\", \"text/html\");\n  addDocumentResponseHeaders(request, responseHeaders);\n\n  return new Response(\"<!DOCTYPE html>\" + markup, {\n    status: responseStatusCode,\n    headers: responseHeaders,\n  });\n}",
                        "title": "entry.server.tsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "registerWebhooks",
                "value": "RegisterWebhooks",
                "description": "Register webhook topics for a store using the given session. Most likely you want to use this in combination with the afterAuth hook.",
                "examples": [
                  {
                    "title": "Registering webhooks after install",
                    "description": "Trigger the registration to create the webhook subscriptions after a merchant installs your app using the `afterAuth` hook. Learn more about [subscribing to webhooks.](/docs/api/shopify-app-remix/v1/guide-webhooks)",
                    "tabs": [
                      {
                        "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  hooks: {\n    afterAuth: async ({ session }) => {\n      shopify.registerWebhooks({ session });\n    }\n  },\n  webhooks: {\n    APP_UNINSTALLED: {\n      deliveryMethod: DeliveryMethod.Http,\n       callbackUrl: \"/webhooks\",\n    },\n  },\n  // ...etc\n});",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authenticate",
                "value": "Authenticate<Config>",
                "description": "Ways to authenticate requests from different surfaces across Shopify.",
                "examples": [
                  {
                    "title": "Authenticate Shopify requests",
                    "description": "Use the functions in `authenticate` to validate requests coming from Shopify.",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const {admin, session, sessionToken, billing} = shopify.authenticate.admin(request);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "unauthenticated",
                "value": "Unauthenticated<RestResourcesType<Config>>",
                "description": "Ways to get Contexts from requests that do not originate from Shopify.",
                "examples": [
                  {
                    "title": "Using unauthenticated contexts",
                    "description": "Create contexts for requests that don't come from Shopify.",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticateExternal } from \"~/helpers/authenticate\"\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const shop = await authenticateExternal(request)\n  const {admin} = await shopify.unauthenticated.admin(shop);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                        "title": "/app/routes/**\\/*.jsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface ShopifyAppBase<Config extends AppConfigArg> {\n  /**\n   * The `SessionStorage` instance you passed in as a config option.\n   *\n   * @example\n   * <caption>Storing sessions with Prisma.</caption>\n   * <description>Import the `@shopify/shopify-app-session-storage-prisma` package to store sessions in your Prisma database.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\n   * import prisma from \"~/db.server\";\n   *\n   * const shopify = shopifyApp({\n   *   sessionStorage: new PrismaSessionStorage(prisma),\n   *   // ...etc\n   * })\n   *\n   * // shopify.sessionStorage is an instance of PrismaSessionStorage\n   * ```\n   */\n  sessionStorage: SessionStorageType<Config>;\n\n  /**\n   * Adds the required Content Security Policy headers for Shopify apps to the given Headers object.\n   *\n   * {@link https://shopify.dev/docs/apps/store/security/iframe-protection}\n   *\n   * @example\n   * <caption>Return headers on all requests.</caption>\n   * <description>Add headers to all HTML requests by calling `shopify.addDocumentResponseHeaders` in `entry.server.tsx`.</description>\n   *\n   * ```\n   * // ~/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const addDocumentResponseheaders = shopify.addDocumentResponseheaders;\n   * ```\n   *\n   * ```ts\n   * // entry.server.tsx\n   * import { addDocumentResponseHeaders } from \"~/shopify.server\";\n   *\n   * export default function handleRequest(\n   *   request: Request,\n   *   responseStatusCode: number,\n   *   responseHeaders: Headers,\n   *   remixContext: EntryContext\n   * ) {\n   *   const markup = renderToString(\n   *     <RemixServer context={remixContext} url={request.url} />\n   *   );\n   *\n   *   responseHeaders.set(\"Content-Type\", \"text/html\");\n   *   addDocumentResponseHeaders(request, responseHeaders);\n   *\n   *   return new Response(\"<!DOCTYPE html>\" + markup, {\n   *     status: responseStatusCode,\n   *     headers: responseHeaders,\n   *   });\n   * }\n   * ```\n   */\n  addDocumentResponseHeaders: AddDocumentResponseHeaders;\n\n  /**\n   * Register webhook topics for a store using the given session. Most likely you want to use this in combination with the afterAuth hook.\n   *\n   * @example\n   * <caption>Registering webhooks after install</caption>\n   * <description>Trigger the registration to create the webhook subscriptions after a merchant installs your app using the `afterAuth` hook. Learn more about [subscribing to webhooks.](/docs/api/shopify-app-remix/v1/guide-webhooks)</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       shopify.registerWebhooks({ session });\n   *     }\n   *   },\n   *   webhooks: {\n   *     APP_UNINSTALLED: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *        callbackUrl: \"/webhooks\",\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  registerWebhooks: RegisterWebhooks;\n\n  /**\n   * Ways to authenticate requests from different surfaces across Shopify.\n   *\n   * @example\n   * <caption>Authenticate Shopify requests.</caption>\n   * <description>Use the functions in `authenticate` to validate requests coming from Shopify.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {admin, session, sessionToken, billing} = shopify.authenticate.admin(request);\n   *\n   *   return json(await admin.rest.resources.Product.count({ session }));\n   * }\n   * ```\n   */\n  authenticate: Authenticate<Config>;\n\n  /**\n   * Ways to get Contexts from requests that do not originate from Shopify.\n   *\n   * @example\n   * <caption>Using unauthenticated contexts.</caption>\n   * <description>Create contexts for requests that don't come from Shopify.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticateExternal } from \"~/helpers/authenticate\"\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const shop = await authenticateExternal(request)\n   *   const {admin} = await shopify.unauthenticated.admin(shop);\n   *\n   *   return json(await admin.rest.resources.Product.count({ session }));\n   * }\n   * ```\n   */\n  unauthenticated: Unauthenticated<RestResourcesType<Config>>;\n}"
          },
          "ShopifyAppLogin": {
            "filePath": "src/server/types.ts",
            "name": "ShopifyAppLogin",
            "description": "",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "Login",
                "description": "Log a merchant in, and redirect them to the app root. Will redirect the merchant to authentication if a shop is present in the URL search parameters or form data.\n\nThis function won't be present when the `distribution` config option is set to `AppDistribution.ShopifyAdmin`, because Admin apps aren't allowed to show a login page.",
                "examples": [
                  {
                    "title": "Creating a login page",
                    "description": "Use `shopify.login` to create a login form, in a route that can handle GET and POST requests.",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;",
                        "title": "/app/shopify.server.ts"
                      },
                      {
                        "code": "import shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const errors = shopify.login(request);\n\n  return json(errors);\n}\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const errors = shopify.login(request);\n\n  return json(errors);\n}\n\nexport default function Auth() {\n  const actionData = useActionData<typeof action>();\n  const [shop, setShop] = useState(\"\");\n\n  return (\n    <Page>\n      <Card>\n        <Form method=\"post\">\n          <FormLayout>\n            <Text variant=\"headingMd\" as=\"h2\">\n              Login\n            </Text>\n            <TextField\n              type=\"text\"\n              name=\"shop\"\n              label=\"Shop domain\"\n              helpText=\"e.g: my-shop-domain.myshopify.com\"\n              value={shop}\n              onChange={setShop}\n              autoComplete=\"on\"\n              error={actionData?.errors.shop}\n            />\n            <Button submit primary>\n              Submit\n            </Button>\n          </FormLayout>\n        </Form>\n      </Card>\n    </Page>\n  );\n}",
                        "title": "/app/routes/auth/login.tsx"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "interface ShopifyAppLogin {\n  /**\n   * Log a merchant in, and redirect them to the app root. Will redirect the merchant to authentication if a shop is\n   * present in the URL search parameters or form data.\n   *\n   * This function won't be present when the `distribution` config option is set to `AppDistribution.ShopifyAdmin`,\n   * because Admin apps aren't allowed to show a login page.\n   *\n   * @example\n   * <caption>Creating a login page.</caption>\n   * <description>Use `shopify.login` to create a login form, in a route that can handle GET and POST requests.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/auth/login.tsx\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const errors = shopify.login(request);\n   *\n   *   return json(errors);\n   * }\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const errors = shopify.login(request);\n   *\n   *   return json(errors);\n   * }\n   *\n   * export default function Auth() {\n   *   const actionData = useActionData<typeof action>();\n   *   const [shop, setShop] = useState(\"\");\n   *\n   *   return (\n   *     <Page>\n   *       <Card>\n   *         <Form method=\"post\">\n   *           <FormLayout>\n   *             <Text variant=\"headingMd\" as=\"h2\">\n   *               Login\n   *             </Text>\n   *             <TextField\n   *               type=\"text\"\n   *               name=\"shop\"\n   *               label=\"Shop domain\"\n   *               helpText=\"e.g: my-shop-domain.myshopify.com\"\n   *               value={shop}\n   *               onChange={setShop}\n   *               autoComplete=\"on\"\n   *               error={actionData?.errors.shop}\n   *             />\n   *             <Button submit primary>\n   *               Submit\n   *             </Button>\n   *           </FormLayout>\n   *         </Form>\n   *       </Card>\n   *     </Page>\n   *   );\n   * }\n   * ```\n   */\n  login: Login;\n}"
          },
          "Login": {
            "filePath": "src/server/types.ts",
            "name": "Login",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/server/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/types.ts",
              "description": "",
              "name": "Promise<LoginError | never>",
              "value": "Promise<LoginError | never>"
            },
            "value": "type Login = (request: Request) => Promise<LoginError | never>;"
          },
          "LoginError": {
            "filePath": "src/server/types.ts",
            "name": "LoginError",
            "description": "",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "LoginErrorType",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface LoginError {\n  shop?: LoginErrorType;\n}"
          },
          "LoginErrorType": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "LoginErrorType",
            "value": "export enum LoginErrorType {\n  MissingShop = 'MISSING_SHOP',\n  InvalidShop = 'INVALID_SHOP',\n}",
            "members": [
              {
                "filePath": "src/server/types.ts",
                "name": "MissingShop",
                "value": "MISSING_SHOP"
              },
              {
                "filePath": "src/server/types.ts",
                "name": "InvalidShop",
                "value": "INVALID_SHOP"
              }
            ]
          },
          "AppStoreApp": {
            "filePath": "src/server/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AppStoreApp",
            "value": "ShopifyAppBase<Config> & ShopifyAppLogin",
            "description": ""
          },
          "AppConfigArg": {
            "filePath": "src/server/config-types.ts",
            "name": "AppConfigArg",
            "description": "",
            "members": [
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "appUrl",
                "value": "string",
                "description": "The URL your app is running on.\n\nThe `@shopify/cli` provides this URL as `process.env.SHOPIFY_APP_URL`.  For development this is probably a tunnel URL that points to your local machine.  If this is a production app, this is your production URL."
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sessionStorage",
                "value": "Storage",
                "description": "An adaptor for storing sessions in your database of choice.\n\nShopify provides multiple session storage adaptors and you can create your own.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Storing sessions with Prisma",
                    "description": "Add the `@shopify/shopify-app-session-storage-prisma` package to use the Prisma session storage.",
                    "tabs": [
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\n\nimport prisma from \"~/db.server\";\n\nconst shopify = shopifyApp({\n  // ... etc\n  sessionStorage: new PrismaSessionStorage(prisma),\n});\nexport default shopify;",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "useOnlineTokens",
                "value": "boolean",
                "description": "Whether your app use online or offline tokens.\n\nIf your app uses online tokens, then both online and offline tokens will be saved to your database.  This ensures your app can perform background jobs.\n\n\n\n\n",
                "isOptional": true,
                "defaultValue": "`false`"
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "webhooks",
                "value": "WebhookConfig",
                "description": "The config for the webhook topics your app would like to subscribe to.\n\n\n\n\n\n\n\nThis can be in used in conjunction with the afterAuth hook to register webhook topics when a user installs your app.  Or you can use this function in other processes such as background jobs.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Registering for a webhook when a merchant uninstalls your app",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  webhooks: {\n    APP_UNINSTALLED: {\n      deliveryMethod: DeliveryMethod.Http,\n       callbackUrl: \"/webhooks\",\n    },\n  },\n  hooks: {\n    afterAuth: async ({ session }) => {\n      shopify.registerWebhooks({ session });\n    }\n  },\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;\n\n// /app/routes/webhooks.jsx\nimport { ActionFunctionArgs } from \"@remix-run/node\";\n\nimport { authenticate } from \"../shopify.server\";\nimport db from \"../db.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { topic, shop } = await authenticate.webhook(request);\n\n  switch (topic) {\n    case \"APP_UNINSTALLED\":\n      await db.session.deleteMany({ where: { shop } });\n      break;\n    case \"CUSTOMERS_DATA_REQUEST\":\n    case \"CUSTOMERS_REDACT\":\n    case \"SHOP_REDACT\":\n    default:\n      throw new Response(\"Unhandled webhook topic\", { status: 404 });\n  }\n  throw new Response();\n};",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hooks",
                "value": "HooksConfig",
                "description": "Functions to call at key places during your apps lifecycle.\n\nThese functions are called in the context of the request that triggered them.  This means you can access the session.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Seeding your database custom data when a merchant installs your app",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { seedStoreData } from \"~/db/seeds\"\n\nconst shopify = shopifyApp({\n  hooks: {\n    afterAuth: async ({ session }) => {\n      seedStoreData({session})\n    }\n  },\n  // ...etc\n});",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isEmbeddedApp",
                "value": "boolean",
                "description": "Does your app render embedded inside the Shopify Admin or on its own.\n\nUnless you have very specific needs, this should be true.",
                "isOptional": true,
                "defaultValue": "`true`"
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "distribution",
                "value": "AppDistribution",
                "description": "How your app is distributed. Default is `AppDistribution.AppStore`.\n\n\n\n\n",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "What version of Shopify's Admin API's would you like to use.\n\n\n\n\n",
                "isOptional": true,
                "defaultValue": "`LATEST_API_VERSION` from `@shopify/shopify-app-remix`",
                "examples": [
                  {
                    "title": "Using the latest API Version (Recommended)",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  apiVersion: LATEST_API_VERSION,\n});",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authPathPrefix",
                "value": "string",
                "description": "A path that Shopify can reserve for auth related endpoints.\n\nThis must match a $ route in your Remix app.  That route must export a loader function that calls `shopify.authenticate.admin(request)`.",
                "isOptional": true,
                "defaultValue": "`\"/auth\"`",
                "examples": [
                  {
                    "title": "Using the latest API Version (Recommended)",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n  apiVersion: LATEST_API_VERSION,\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;\n\n// /app/routes/auth/$.jsx\nimport { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  await authenticate.admin(request);\n\n  return null\n}",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "future",
                "value": "Future",
                "description": "Features that will be introduced in future releases of this package.\n\nYou can opt in to these features by setting the corresponding flags. By doing so, you can prepare for future releases in advance and provide feedback on the new features.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiKey",
                "value": "string",
                "description": "The API key for your app.\n\nAlso known as Client ID in your Partner Dashboard.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiSecretKey",
                "value": "string",
                "description": "The API secret key for your app.\n\nAlso known as Client Secret in your Partner Dashboard."
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scopes",
                "value": "string[] | AuthScopes",
                "description": "The scopes your app needs to access the API.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "adminApiAccessToken",
                "value": "string",
                "description": "An app-wide API access token.\n\nOnly applies to custom apps.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userAgentPrefix",
                "value": "string",
                "description": "The user agent prefix to use for API requests.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "privateAppStorefrontAccessToken",
                "value": "string",
                "description": "An app-wide API access token for the storefront API.\n\nOnly applies to custom apps.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customShopDomains",
                "value": "(string | RegExp)[]",
                "description": "Override values for Shopify shop domains.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "billing",
                "value": "BillingConfig<Future>",
                "description": "Billing configurations for the app.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "restResources",
                "value": "Resources",
                "description": "REST resources to access the Admin API.\n\nYou can import these from `@shopify/shopify-api/rest/admin/*`.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logger",
                "value": "{ log?: LogFunction; level?: LogSeverity; httpRequests?: boolean; timestamps?: boolean; }",
                "description": "Customization options for Shopify logs.",
                "isOptional": true
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "_logDisabledFutureFlags",
                "value": "boolean",
                "description": "Whether to log disabled future flags at startup.",
                "isOptional": true,
                "isPrivate": true
              }
            ],
            "value": "export interface AppConfigArg<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n  Storage extends SessionStorage = SessionStorage,\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> extends Omit<\n    ApiConfigArg<Resources, ApiFutureFlags<Future>>,\n    | 'hostName'\n    | 'hostScheme'\n    | 'isEmbeddedApp'\n    | 'apiVersion'\n    | 'isCustomStoreApp'\n    | 'future'\n  > {\n  /**\n   * The URL your app is running on.\n   *\n   * The `@shopify/cli` provides this URL as `process.env.SHOPIFY_APP_URL`.  For development this is probably a tunnel URL that points to your local machine.  If this is a production app, this is your production URL.\n   */\n  appUrl: string;\n\n  /**\n   * An adaptor for storing sessions in your database of choice.\n   *\n   * Shopify provides multiple session storage adaptors and you can create your own.\n   *\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/README.md#session-storage-options}\n   *\n   * @example\n   * <caption>Storing sessions with Prisma.</caption>\n   * <description>Add the `@shopify/shopify-app-session-storage-prisma` package to use the Prisma session storage.</description>\n   * ```ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\n   *\n   * import prisma from \"~/db.server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ... etc\n   *   sessionStorage: new PrismaSessionStorage(prisma),\n   * });\n   * export default shopify;\n   * ```\n   */\n  sessionStorage: Storage;\n\n  /**\n   * Whether your app use online or offline tokens.\n   *\n   * If your app uses online tokens, then both online and offline tokens will be saved to your database.  This ensures your app can perform background jobs.\n   *\n   * {@link https://shopify.dev/docs/apps/auth/oauth/access-modes}\n   *\n   * @defaultValue `false`\n   */\n  useOnlineTokens?: boolean;\n\n  /**\n   * The config for the webhook topics your app would like to subscribe to.\n   *\n   * {@link https://shopify.dev/docs/apps/webhooks}\n   *\n   * This can be in used in conjunction with the afterAuth hook to register webhook topics when a user installs your app.  Or you can use this function in other processes such as background jobs.\n   *\n   * @example\n   * <caption>Registering for a webhook when a merchant uninstalls your app.</caption>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   webhooks: {\n   *     APP_UNINSTALLED: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *        callbackUrl: \"/webhooks\",\n   *     },\n   *   },\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       shopify.registerWebhooks({ session });\n   *     }\n   *   },\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   *\n   * // /app/routes/webhooks.jsx\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   *\n   * import { authenticate } from \"../shopify.server\";\n   * import db from \"../db.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { topic, shop } = await authenticate.webhook(request);\n   *\n   *   switch (topic) {\n   *     case \"APP_UNINSTALLED\":\n   *       await db.session.deleteMany({ where: { shop } });\n   *       break;\n   *     case \"CUSTOMERS_DATA_REQUEST\":\n   *     case \"CUSTOMERS_REDACT\":\n   *     case \"SHOP_REDACT\":\n   *     default:\n   *       throw new Response(\"Unhandled webhook topic\", { status: 404 });\n   *   }\n   *   throw new Response();\n   * };\n   * ```\n   */\n  webhooks?: WebhookConfig;\n\n  /**\n   * Functions to call at key places during your apps lifecycle.\n   *\n   * These functions are called in the context of the request that triggered them.  This means you can access the session.\n   *\n   * @example\n   * <caption>Seeding your database custom data when a merchant installs your app.</caption>\n   * ```ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { seedStoreData } from \"~/db/seeds\"\n   *\n   * const shopify = shopifyApp({\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       seedStoreData({session})\n   *     }\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  hooks?: HooksConfig;\n\n  /**\n   * Does your app render embedded inside the Shopify Admin or on its own.\n   *\n   * Unless you have very specific needs, this should be true.\n   *\n   * @defaultValue `true`\n   */\n  isEmbeddedApp?: boolean;\n\n  /**\n   * How your app is distributed. Default is `AppDistribution.AppStore`.\n   *\n   * {@link https://shopify.dev/docs/apps/distribution}\n   */\n  distribution?: AppDistribution;\n\n  /**\n   * What version of Shopify's Admin API's would you like to use.\n   *\n   * {@link https://shopify.dev/docs/api/}\n   *\n   * @defaultValue `LATEST_API_VERSION` from `@shopify/shopify-app-remix`\n   *\n   * @example\n   * <caption>Using the latest API Version (Recommended)</caption>\n   * ```ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   apiVersion: LATEST_API_VERSION,\n   * });\n   * ```\n   */\n  apiVersion?: ApiVersion;\n\n  /**\n   * A path that Shopify can reserve for auth related endpoints.\n   *\n   * This must match a $ route in your Remix app.  That route must export a loader function that calls `shopify.authenticate.admin(request)`.\n   *\n   * @default `\"/auth\"`\n   *\n   * @example\n   * <caption>Using the latest API Version (Recommended)</caption>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   *   apiVersion: LATEST_API_VERSION,\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   *\n   * // /app/routes/auth/$.jsx\n   * import { LoaderFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   await authenticate.admin(request);\n   *\n   *   return null\n   * }\n   * ```\n   */\n  authPathPrefix?: string;\n\n  /**\n   * Features that will be introduced in future releases of this package.\n   *\n   * You can opt in to these features by setting the corresponding flags. By doing so, you can prepare for future\n   * releases in advance and provide feedback on the new features.\n   */\n  future?: Future;\n}"
          },
          "WebhookConfig": {
            "filePath": "src/server/config-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "WebhookConfig",
            "value": "Record<string, WebhookHandler | WebhookHandler[]>",
            "description": "",
            "members": []
          },
          "HooksConfig": {
            "filePath": "src/server/config-types.ts",
            "name": "HooksConfig",
            "description": "",
            "members": [
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "afterAuth",
                "value": "(options: AfterAuthOptions<ShopifyRestResources>) => void | Promise<void>",
                "description": "A function to call after a merchant installs your app",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Registering webhooks and seeding data when a merchant installs your app",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { seedStoreData } from \"~/db/seeds\"\n\nconst shopify = shopifyApp({\n  hooks: {\n    afterAuth: async ({ session }) => {\n      shopify.registerWebhooks({ session });\n      seedStoreData({session})\n    }\n  },\n  webhooks: {\n    APP_UNINSTALLED: {\n      deliveryMethod: DeliveryMethod.Http,\n       callbackUrl: \"/webhooks\",\n    },\n  },\n  // ...etc\n});",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "interface HooksConfig {\n  /**\n   * A function to call after a merchant installs your app\n   *\n   * @param context - An object with context about the request that triggered the hook.\n   * @param context.session - The session of the merchant that installed your app. This is the output of sessionStorage.loadSession in case people want to load their own.\n   * @param context.admin - An object with access to the Shopify Admin API's.\n   *\n   * @example\n   * <caption>Registering webhooks and seeding data when a merchant installs your app.</caption>\n   * ```ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { seedStoreData } from \"~/db/seeds\"\n   *\n   * const shopify = shopifyApp({\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       shopify.registerWebhooks({ session });\n   *       seedStoreData({session})\n   *     }\n   *   },\n   *   webhooks: {\n   *     APP_UNINSTALLED: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *        callbackUrl: \"/webhooks\",\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  afterAuth?: (options: AfterAuthOptions) => void | Promise<void>;\n}"
          },
          "AfterAuthOptions": {
            "filePath": "src/server/config-types.ts",
            "name": "AfterAuthOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/config-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<R>",
                "description": ""
              }
            ],
            "value": "export interface AfterAuthOptions<\n  R extends ShopifyRestResources = ShopifyRestResources,\n> {\n  session: Session;\n  admin: AdminApiContext<R>;\n}"
          },
          "BillingConfig": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfig",
            "description": "Billing configuration options, indexed by an app-specific plan name.",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "name": "[plan: string]",
                "value": "BillingConfigItem<Future>"
              }
            ],
            "value": "export interface BillingConfig<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> {\n  /**\n   * An individual billing plan.\n   */\n  [plan: string]: BillingConfigItem<Future>;\n}"
          },
          "BillingConfigItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "BillingConfigItem",
            "value": "FeatureEnabled<Future, 'v10_lineItemBilling'> extends true\n    ? BillingConfigOneTimePlan | BillingConfigSubscriptionLineItemPlan\n    : BillingConfigLegacyItem",
            "description": ""
          },
          "BillingConfigOneTimePlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigOneTimePlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.OneTime",
                "description": "Interval for this plan.\n\nMust be set to `OneTime`."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "Amount to charge for this plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": "Currency code for this plan."
              }
            ],
            "value": "export interface BillingConfigOneTimePlan extends BillingConfigPlan {\n  /**\n   * Interval for this plan.\n   *\n   * Must be set to `OneTime`.\n   */\n  interval: BillingInterval.OneTime;\n}"
          },
          "BillingConfigSubscriptionLineItemPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionLineItemPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "replacementBehavior",
                "value": "BillingReplacementBehavior",
                "description": "The replacement behavior to use for this plan.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "trialDays",
                "value": "number",
                "description": "How many trial days to give before charging for this plan.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "lineItems",
                "value": "(BillingConfigRecurringLineItem | BillingConfigUsageLineItem)[]",
                "description": "The line items for this plan."
              }
            ],
            "value": "export interface BillingConfigSubscriptionLineItemPlan {\n  /**\n   * The replacement behavior to use for this plan.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The line items for this plan.\n   */\n  lineItems: (BillingConfigRecurringLineItem | BillingConfigUsageLineItem)[];\n}"
          },
          "BillingReplacementBehavior": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "BillingReplacementBehavior",
            "value": "export enum BillingReplacementBehavior {\n  ApplyImmediately = 'APPLY_IMMEDIATELY',\n  ApplyOnNextBillingCycle = 'APPLY_ON_NEXT_BILLING_CYCLE',\n  Standard = 'STANDARD',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "ApplyImmediately",
                "value": "APPLY_IMMEDIATELY"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "ApplyOnNextBillingCycle",
                "value": "APPLY_ON_NEXT_BILLING_CYCLE"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Standard",
                "value": "STANDARD"
              }
            ]
          },
          "BillingConfigRecurringLineItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigRecurringLineItem",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Every30Days | BillingInterval.Annual",
                "description": "The recurring interval for this line item.\n\nMust be either `Every30Days` or `Annual`."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "discount",
                "value": "BillingConfigSubscriptionPlanDiscount",
                "description": "An optional discount to apply for this line item.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "The amount to charge for this line item."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": "The currency code for this line item."
              }
            ],
            "value": "export interface BillingConfigRecurringLineItem extends BillingConfigLineItem {\n  /**\n   * The recurring interval for this line item.\n   *\n   * Must be either `Every30Days` or `Annual`.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /**\n   * An optional discount to apply for this line item.\n   */\n  discount?: BillingConfigSubscriptionPlanDiscount;\n}"
          },
          "BillingConfigSubscriptionPlanDiscount": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlanDiscount",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "durationLimitInIntervals",
                "value": "number",
                "description": "The number of intervals to apply the discount for.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "BillingConfigSubscriptionPlanDiscountAmount | BillingConfigSubscriptionPlanDiscountPercentage",
                "description": "The discount to apply."
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlanDiscount {\n  /**\n   * The number of intervals to apply the discount for.\n   */\n  durationLimitInIntervals?: number;\n  /**\n   * The discount to apply.\n   */\n  value:\n    | BillingConfigSubscriptionPlanDiscountAmount\n    | BillingConfigSubscriptionPlanDiscountPercentage;\n}"
          },
          "BillingConfigUsageLineItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigUsageLineItem",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Usage",
                "description": "The usage interval for this line item.\n\nMust be set to `Usage`."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "terms",
                "value": "string",
                "description": "Usage terms for this line item."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "The amount to charge for this line item."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": "The currency code for this line item."
              }
            ],
            "value": "export interface BillingConfigUsageLineItem extends BillingConfigLineItem {\n  /**\n   * The usage interval for this line item.\n   *\n   * Must be set to `Usage`.\n   */\n  interval: BillingInterval.Usage;\n  /**\n   * Usage terms for this line item.\n   */\n  terms: string;\n}"
          },
          "BillingConfigLegacyItem": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "BillingConfigLegacyItem",
            "value": "BillingConfigOneTimePlan | BillingConfigSubscriptionPlan | BillingConfigUsagePlan",
            "description": ""
          },
          "BillingConfigSubscriptionPlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigSubscriptionPlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "Exclude<RecurringBillingIntervals, BillingInterval.Usage>",
                "description": "Recurring interval for this plan.\n\nMust be either `Every30Days` or `Annual`."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "trialDays",
                "value": "number",
                "description": "How many trial days to give before charging for this plan.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "replacementBehavior",
                "value": "BillingReplacementBehavior",
                "description": "The behavior to use when replacing an existing subscription with a new one.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "discount",
                "value": "BillingConfigSubscriptionPlanDiscount",
                "description": "The discount to apply to this plan.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "Amount to charge for this plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": "Currency code for this plan."
              }
            ],
            "value": "export interface BillingConfigSubscriptionPlan extends BillingConfigPlan {\n  /**\n   * Recurring interval for this plan.\n   *\n   * Must be either `Every30Days` or `Annual`.\n   */\n  interval: Exclude<RecurringBillingIntervals, BillingInterval.Usage>;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The behavior to use when replacing an existing subscription with a new one.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n  /**\n   * The discount to apply to this plan.\n   */\n  discount?: BillingConfigSubscriptionPlanDiscount;\n}"
          },
          "RecurringBillingIntervals": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RecurringBillingIntervals",
            "value": "RecurringBillingIntervals",
            "description": ""
          },
          "BillingConfigUsagePlan": {
            "filePath": "../shopify-api/lib/billing/types.ts",
            "name": "BillingConfigUsagePlan",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "interval",
                "value": "BillingInterval.Usage",
                "description": "Interval for this plan.\n\nMust be set to `Usage`."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "usageTerms",
                "value": "string",
                "description": "Usage terms for this plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "trialDays",
                "value": "number",
                "description": "How many trial days to give before charging for this plan.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "replacementBehavior",
                "value": "BillingReplacementBehavior",
                "description": "The behavior to use when replacing an existing subscription with a new one.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "number",
                "description": "Amount to charge for this plan."
              },
              {
                "filePath": "../shopify-api/lib/billing/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "string",
                "description": "Currency code for this plan."
              }
            ],
            "value": "export interface BillingConfigUsagePlan extends BillingConfigPlan {\n  /**\n   * Interval for this plan.\n   *\n   * Must be set to `Usage`.\n   */\n  interval: BillingInterval.Usage;\n  /**\n   * Usage terms for this plan.\n   */\n  usageTerms: string;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The behavior to use when replacing an existing subscription with a new one.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n}"
          },
          "LogFunction": {
            "filePath": "../shopify-api/lib/base-types.ts",
            "name": "LogFunction",
            "description": "A function used by the library to log events related to Shopify.",
            "params": [
              {
                "name": "severity",
                "description": "",
                "value": "LogSeverity",
                "filePath": "../shopify-api/lib/base-types.ts"
              },
              {
                "name": "msg",
                "description": "",
                "value": "string",
                "filePath": "../shopify-api/lib/base-types.ts"
              }
            ],
            "returns": {
              "filePath": "../shopify-api/lib/base-types.ts",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "export type LogFunction = (severity: LogSeverity, msg: string) => void;"
          },
          "LogSeverity": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "LogSeverity",
            "value": "export enum LogSeverity {\n  Error,\n  Warning,\n  Info,\n  Debug,\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Error",
                "value": 0
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Warning",
                "value": 1
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Info",
                "value": 2
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Debug",
                "value": 3
              }
            ]
          }
        }
      },
      {
        "title": "Future flags",
        "description": "Set future flags using the `future` configuration field to opt in to upcoming breaking changes.\n\nWith this feature, you can prepare for major releases ahead of time, as well as try out new features before they are released.",
        "type": "FutureFlags",
        "typeDefinitions": {
          "FutureFlags": {
            "filePath": "src/server/future/flags.ts",
            "name": "FutureFlags",
            "description": "",
            "members": [
              {
                "filePath": "src/server/future/flags.ts",
                "syntaxKind": "PropertySignature",
                "name": "v3_webhookAdminContext",
                "value": "boolean",
                "description": "When enabled, returns the same `admin` context (`AdminApiContext`) from `authenticate.webhook` that is returned from `authenticate.admin`.",
                "isOptional": true,
                "defaultValue": "false"
              },
              {
                "filePath": "src/server/future/flags.ts",
                "syntaxKind": "PropertySignature",
                "name": "v3_authenticatePublic",
                "value": "boolean",
                "description": "When enabled authenticate.public() will not work.  Use authenticate.public.checkout() instead.",
                "isOptional": true,
                "defaultValue": "false"
              },
              {
                "filePath": "src/server/future/flags.ts",
                "syntaxKind": "PropertySignature",
                "name": "v3_lineItemBilling",
                "value": "boolean",
                "description": "When enabled allows you to pass billing plans with line items when creating a new app subscriptions.",
                "isOptional": true
              },
              {
                "filePath": "src/server/future/flags.ts",
                "syntaxKind": "PropertySignature",
                "name": "unstable_newEmbeddedAuthStrategy",
                "value": "boolean",
                "description": "When enabled, embedded apps will fetch access tokens via [token exchange](https://shopify.dev/docs/apps/auth/get-access-tokens/token-exchange). This assumes the app has scopes declared for [Shopify managing installation](https://shopify.dev/docs/apps/auth/installation#shopify-managed-installation).\n\nLearn more about this [new embedded app auth strategy](https://shopify.dev/docs/api/shopify-app-remix#embedded-auth-strategy).",
                "isOptional": true,
                "defaultValue": "false"
              }
            ],
            "value": "export interface FutureFlags {\n  /**\n   * When enabled, returns the same `admin` context (`AdminApiContext`) from `authenticate.webhook` that is returned from `authenticate.admin`.\n   *\n   * @default false\n   */\n  v3_webhookAdminContext?: boolean;\n\n  /**\n   * When enabled authenticate.public() will not work.  Use authenticate.public.checkout() instead.\n   *\n   * @default false\n   */\n  v3_authenticatePublic?: boolean;\n\n  /**\n   * When enabled allows you to pass billing plans with line items when creating a new app subscriptions.\n   */\n  v3_lineItemBilling?: boolean;\n\n  /**\n   * When enabled, embedded apps will fetch access tokens via [token exchange](https://shopify.dev/docs/apps/auth/get-access-tokens/token-exchange).\n   * This assumes the app has scopes declared for [Shopify managing installation](https://shopify.dev/docs/apps/auth/installation#shopify-managed-installation).\n   *\n   * Learn more about this [new embedded app auth strategy](https://shopify.dev/docs/api/shopify-app-remix#embedded-auth-strategy).\n   *\n   * @default false\n   */\n  unstable_newEmbeddedAuthStrategy?: boolean;\n}"
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "ShopifyAppGeneratedType",
      "ShopifyAppBase",
      "ShopifyAppLogin"
    ],
    "related": [
      {
        "name": "Authenticated contexts",
        "subtitle": "Authenticate requests coming from Shopify.",
        "url": "/docs/api/shopify-app-remix/authenticate"
      },
      {
        "name": "Unauthenticated contexts",
        "subtitle": "Interact with the API on non-Shopify requests.",
        "url": "/docs/api/shopify-app-remix/unauthenticated"
      }
    ],
    "defaultExample": {
      "description": "",
      "codeblock": {
        "title": "The minimum viable configuration",
        "tabs": [
          {
            "title": "/shopify.server.ts",
            "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  apiKey: process.env.SHOPIFY_API_KEY!,\n  apiSecretKey: process.env.SHOPIFY_API_SECRET!,\n  scopes: process.env.SCOPES?.split(\",\")!,\n  appUrl: process.env.SHOPIFY_APP_URL!,\n});\nexport default shopify;",
            "language": "typescript"
          }
        ]
      }
    },
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "sessionStorage",
          "examples": [
            {
              "description": "Import the `@shopify/shopify-app-session-storage-prisma` package to store sessions in your Prisma database.",
              "codeblock": {
                "title": "Storing sessions with Prisma",
                "tabs": [
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\nimport prisma from \"~/db.server\";\n\nconst shopify = shopifyApp({\n  sessionStorage: new PrismaSessionStorage(prisma),\n  // ...etc\n})\n\n// shopify.sessionStorage is an instance of PrismaSessionStorage",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "addDocumentResponseHeaders",
          "examples": [
            {
              "description": "Add headers to all HTML requests by calling `shopify.addDocumentResponseHeaders` in `entry.server.tsx`.",
              "codeblock": {
                "title": "Return headers on all requests",
                "tabs": [
                  {
                    "title": "~/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;\nexport const addDocumentResponseheaders = shopify.addDocumentResponseheaders;",
                    "language": "typescript"
                  },
                  {
                    "title": "entry.server.tsx",
                    "code": "import { addDocumentResponseHeaders } from \"~/shopify.server\";\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  const markup = renderToString(\n    &lt;RemixServer context={remixContext} url={request.url} /&gt;\n  );\n\n  responseHeaders.set(\"Content-Type\", \"text/html\");\n  addDocumentResponseHeaders(request, responseHeaders);\n\n  return new Response(\"&lt;!DOCTYPE html&gt;\" + markup, {\n    status: responseStatusCode,\n    headers: responseHeaders,\n  });\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "registerWebhooks",
          "examples": [
            {
              "description": "Trigger the registration to create the webhook subscriptions after a merchant installs your app using the `afterAuth` hook. Learn more about [subscribing to webhooks.](/docs/api/shopify-app-remix/v1/guide-webhooks)",
              "codeblock": {
                "title": "Registering webhooks after install",
                "tabs": [
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  hooks: {\n    afterAuth: async ({ session }) =&gt; {\n      shopify.registerWebhooks({ session });\n    }\n  },\n  webhooks: {\n    APP_UNINSTALLED: {\n      deliveryMethod: DeliveryMethod.Http,\n       callbackUrl: \"/webhooks\",\n    },\n  },\n  // ...etc\n});",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "authenticate",
          "examples": [
            {
              "description": "Use the functions in `authenticate` to validate requests coming from Shopify.",
              "codeblock": {
                "title": "Authenticate Shopify requests",
                "tabs": [
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/routes/**\\/*.jsx",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const {admin, session, sessionToken, billing} = shopify.authenticate.admin(request);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "unauthenticated",
          "examples": [
            {
              "description": "Create contexts for requests that don't come from Shopify.",
              "codeblock": {
                "title": "Using unauthenticated contexts",
                "tabs": [
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/routes/**\\/*.jsx",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticateExternal } from \"~/helpers/authenticate\"\nimport shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const shop = await authenticateExternal(request)\n  const {admin} = await shopify.unauthenticated.admin(shop);\n\n  return json(await admin.rest.resources.Product.count({ session }));\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "login",
          "examples": [
            {
              "description": "Use `shopify.login` to create a login form, in a route that can handle GET and POST requests.",
              "codeblock": {
                "title": "Creating a login page",
                "tabs": [
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...etc\n});\nexport default shopify;",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/routes/auth/login.tsx",
                    "code": "import shopify from \"../../shopify.server\";\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const errors = shopify.login(request);\n\n  return json(errors);\n}\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const errors = shopify.login(request);\n\n  return json(errors);\n}\n\nexport default function Auth() {\n  const actionData = useActionData&lt;typeof action&gt;();\n  const [shop, setShop] = useState(\"\");\n\n  return (\n    &lt;Page&gt;\n      &lt;Card&gt;\n        &lt;Form method=\"post\"&gt;\n          &lt;FormLayout&gt;\n            &lt;Text variant=\"headingMd\" as=\"h2\"&gt;\n              Login\n            &lt;/Text&gt;\n            &lt;TextField\n              type=\"text\"\n              name=\"shop\"\n              label=\"Shop domain\"\n              helpText=\"e.g: my-shop-domain.myshopify.com\"\n              value={shop}\n              onChange={setShop}\n              autoComplete=\"on\"\n              error={actionData?.errors.shop}\n            /&gt;\n            &lt;Button submit primary&gt;\n              Submit\n            &lt;/Button&gt;\n          &lt;/FormLayout&gt;\n        &lt;/Form&gt;\n      &lt;/Card&gt;\n    &lt;/Page&gt;\n  );\n}",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Unauthenticated admin",
    "description": "Allows interacting with the Admin API when working outside of Shopify requests.\nThis enables apps to integrate with 3rd party services and perform background tasks.\n\n> Caution:\n> This function doesn't perform **any** validation and shouldn't rely on raw user input.\n\nWhen using this function, consider the following:\n\n#### Background tasks\n\nApps should ensure that the shop domain is authenticated when enqueueing jobs.\n\n#### 3rd party service requests\n\nApps must obtain the shop domain from the 3rd party service in a secure way.",
    "category": "Unauthenticated",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "unauthenticated.admin",
        "description": "Creates an unauthenticated Admin context.",
        "type": "GetUnauthenticatedAdminContext",
        "typeDefinitions": {
          "GetUnauthenticatedAdminContext": {
            "filePath": "src/server/unauthenticated/admin/types.ts",
            "name": "GetUnauthenticatedAdminContext",
            "description": "",
            "params": [
              {
                "name": "shop",
                "description": "",
                "value": "string",
                "filePath": "src/server/unauthenticated/admin/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/unauthenticated/admin/types.ts",
              "description": "",
              "name": "Promise<UnauthenticatedAdminContext<Resources>>",
              "value": "Promise<UnauthenticatedAdminContext<Resources>>"
            },
            "value": "export type GetUnauthenticatedAdminContext<\n  Resources extends ShopifyRestResources,\n> = (shop: string) => Promise<UnauthenticatedAdminContext<Resources>>;"
          },
          "UnauthenticatedAdminContext": {
            "filePath": "src/server/unauthenticated/admin/types.ts",
            "name": "UnauthenticatedAdminContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/unauthenticated/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the given shop.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nThis will always be an offline session. You can use to get shop-specific data.",
                "examples": [
                  {
                    "title": "Using the offline session",
                    "description": "Get your app's shop-specific data using the returned offline `session` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const shop = getShopFromExternalRequest(request);\n  const { session } = await unauthenticated.admin(shop);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "/app/routes/**\\/*.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/unauthenticated/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "admin",
                "value": "AdminApiContext<Resources>",
                "description": "Methods for interacting with the GraphQL / REST Admin APIs for the given store.",
                "examples": [
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n const { admin, session } = await unauthenticated.admin(request);\n\n const response = await admin.rest.get(\n   {\n     path: \"/customers/count.json\"\n   }\n );\n const customers = await response.json();\n\n return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n restResources,\n // ...etc\n});\n\nexport default shopify;\nexport const unauthenticated = shopify.unauthenticated;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n const { admin } = await unauthenticated.admin(request);\n\n const response = await admin.graphql(\n   `#graphql\n   mutation populateProduct($input: ProductInput!) {\n     productCreate(input: $input) {\n       product {\n         id\n       }\n     }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n const productData = await response.json();\n return json({ data: productData.data });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n restResources,\n // ...etc\n});\nexport default shopify;\nexport const unauthenticated = shopify.unauthenticated;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface UnauthenticatedAdminContext<\n  Resources extends ShopifyRestResources,\n> {\n  /**\n   * The session for the given shop.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   *\n   * This will always be an offline session. You can use to get shop-specific data.\n   *\n   * @example\n   * <caption>Using the offline session.</caption>\n   * <description>Get your app's shop-specific data using the returned offline `session` object.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const shop = getShopFromExternalRequest(request);\n   *   const { session } = await unauthenticated.admin(shop);\n   *   return json(await getMyAppData({shop: session.shop));\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * Methods for interacting with the GraphQL / REST Admin APIs for the given store.\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *  const { admin, session } = await unauthenticated.admin(request);\n   *\n   *  const response = await admin.rest.get(\n   *    {\n   *      path: \"/customers/count.json\"\n   *    }\n   *  );\n   *  const customers = await response.json();\n   *\n   *  return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *  restResources,\n   *  // ...etc\n   * });\n   *\n   * export default shopify;\n   * export const unauthenticated = shopify.unauthenticated;\n   * ```\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *  const { admin } = await unauthenticated.admin(request);\n   *\n   *  const response = await admin.graphql(\n   *    `#graphql\n   *    mutation populateProduct($input: ProductInput!) {\n   *      productCreate(input: $input) {\n   *        product {\n   *          id\n   *        }\n   *      }\n   *     }`,\n   *     { variables: { input: { title: \"Product Name\" } } }\n   *   );\n   *\n   *  const productData = await response.json();\n   *  return json({ data: productData.data });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *  restResources,\n   *  // ...etc\n   * });\n   * export default shopify;\n   * export const unauthenticated = shopify.unauthenticated;\n   * ```\n   */\n  admin: AdminApiContext<Resources>;\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "AdminApiContext": {
            "filePath": "src/server/clients/admin/types.ts",
            "name": "AdminApiContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "rest",
                "value": "RestClientWithResources<Resources>",
                "description": "Methods for interacting with the Shopify Admin REST API\n\nThere are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Using REST resources",
                    "description": "Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  return json(\n    admin.rest.resources.Order.count({ session }),\n  );\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a GET request to the REST API",
                    "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = await admin.rest.get({\n    path: \"/customers/count.json\",\n  });\n  const customers = await response.json();\n\n  return json({ customers });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Performing a POST request to the REST API",
                    "description": "Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const {\n    admin,\n    session,\n  } = await authenticate.admin(request);\n\n  const response = admin.rest.post({\n    path: \"customers/7392136888625/send_invite.json\",\n    body: {\n      customer_invite: {\n        to: \"new_test_email@shopify.com\",\n        from: \"j.limited@example.com\",\n        bcc: [\"j.limited@example.com\"],\n        subject: \"Welcome to my new shop\",\n        custom_message: \"My awesome new store\",\n      },\n    },\n  });\n\n  const customerInvite = await response.json();\n  return json({ customerInvite });\n};",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n  restResources,\n  // ...etc\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/clients/admin/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<AdminOperations>",
                "description": "Methods for interacting with the Shopify Admin GraphQL API\n\n\n\n\n\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `admin.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  const response = await admin.graphql(\n    `#graphql\n    mutation populateProduct($input: ProductInput!) {\n      productCreate(input: $input) {\n        product {\n          id\n        }\n      }\n    }`,\n    {\n      variables: {\n        input: { title: \"Product Name\" },\n      },\n    },\n  );\n\n  const productData = await response.json();\n  return json({\n    productId: productData.data?.productCreate?.product?.id,\n  });\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { admin } = await authenticate.admin(request);\n\n  try {\n    const response = await admin.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // error.body.errors:\n      // { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface AdminApiContext<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> {\n  /**\n   * Methods for interacting with the Shopify Admin REST API\n   *\n   * There are methods for interacting with individual REST resources. You can also make `GET`, `POST`, `PUT` and `DELETE` requests should the REST resources not meet your needs.\n   *\n   * {@link https://shopify.dev/docs/api/admin-rest}\n   *\n   * @example\n   * <caption>Using REST resources.</caption>\n   * <description>Getting the number of orders in a store using REST resources. Visit the [Admin REST API references](/docs/api/admin-rest) for examples on using each resource. </description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   return json(\n   *     admin.rest.resources.Order.count({ session }),\n   *   );\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-07\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a GET request to the REST API.</caption>\n   * <description>Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint</description>\n   *\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = await admin.rest.get({\n   *     path: \"/customers/count.json\",\n   *   });\n   *   const customers = await response.json();\n   *\n   *   return json({ customers });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Performing a POST request to the REST API.</caption>\n   * <description>Use `admin.rest.post` to make custom requests to make a request to to the `customers.json` endpoint to send a welcome email</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const {\n   *     admin,\n   *     session,\n   *   } = await authenticate.admin(request);\n   *\n   *   const response = admin.rest.post({\n   *     path: \"customers/7392136888625/send_invite.json\",\n   *     body: {\n   *       customer_invite: {\n   *         to: \"new_test_email@shopify.com\",\n   *         from: \"j.limited@example.com\",\n   *         bcc: [\"j.limited@example.com\"],\n   *         subject: \"Welcome to my new shop\",\n   *         custom_message: \"My awesome new store\",\n   *       },\n   *     },\n   *   });\n   *\n   *   const customerInvite = await response.json();\n   *   return json({ customerInvite });\n   * };\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n   *\n   * const shopify = shopifyApp({\n   *   restResources,\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  rest: RestClientWithResources<Resources>;\n\n  /**\n   * Methods for interacting with the Shopify Admin GraphQL API\n   *\n   * {@link https://shopify.dev/docs/api/admin-graphql}\n   * {@link https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/reference/clients/Graphql.md}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `admin.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   const response = await admin.graphql(\n   *     `#graphql\n   *     mutation populateProduct($input: ProductInput!) {\n   *       productCreate(input: $input) {\n   *         product {\n   *           id\n   *         }\n   *       }\n   *     }`,\n   *     {\n   *       variables: {\n   *         input: { title: \"Product Name\" },\n   *       },\n   *     },\n   *   );\n   *\n   *   const productData = await response.json();\n   *   return json({\n   *     productId: productData.data?.productCreate?.product?.id,\n   *   });\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { admin } = await authenticate.admin(request);\n   *\n   *   try {\n   *     const response = await admin.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // error.body.errors:\n   *       // { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<AdminOperations>;\n}"
          },
          "RestClientWithResources": {
            "filePath": "src/server/clients/admin/rest.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RestClientWithResources",
            "value": "RemixRestClient & {resources: Resources}",
            "description": ""
          },
          "RemixRestClient": {
            "filePath": "src/server/clients/admin/rest.ts",
            "name": "RemixRestClient",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "session",
                "value": "Session",
                "description": ""
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "get",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a GET request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "post",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a POST request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "put",
                "value": "(params: PostRequestParams) => Promise<Response>",
                "description": "Performs a PUT request on the given path."
              },
              {
                "filePath": "src/server/clients/admin/rest.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "delete",
                "value": "(params: GetRequestParams) => Promise<Response>",
                "description": "Performs a DELETE request on the given path."
              }
            ],
            "value": "class RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}"
          },
          "GetRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "name": "GetRequestParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "The path to the resource, relative to the API version root."
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "DataType",
                "description": "The type of data expected in the response.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string | Record<string, any>",
                "description": "The request body.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "SearchParams",
                "description": "Query parameters to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extraHeaders",
                "value": "HeaderParams",
                "description": "Additional headers to be sent with the request.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The maximum number of times the request can be made if it fails with a throttling or server error.",
                "isOptional": true
              }
            ],
            "value": "export interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}"
          },
          "DataType": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "DataType",
            "value": "export enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "JSON",
                "value": "application/json"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "GraphQL",
                "value": "application/graphql"
              },
              {
                "filePath": "../shopify-api/lib/clients/types.ts",
                "name": "URLEncoded",
                "value": "application/x-www-form-urlencoded"
              }
            ]
          },
          "HeaderParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HeaderParams",
            "value": "Record<string, string | number | string[]>",
            "description": "Headers to be sent with the request.",
            "members": []
          },
          "PostRequestParams": {
            "filePath": "../shopify-api/lib/clients/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PostRequestParams",
            "value": "GetRequestParams & {\n  data: Record<string, any> | string;\n}",
            "description": ""
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "UnauthenticatedAdminContext"
    ],
    "related": [
      {
        "name": "API context",
        "subtitle": "Interact with the Admin API.",
        "url": "/docs/api/shopify-app-remix/apis/admin-api"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "session",
          "examples": [
            {
              "description": "Get your app's shop-specific data using the returned offline `session` object.",
              "codeblock": {
                "title": "Using the offline session",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const shop = getShopFromExternalRequest(request);\n  const { session } = await unauthenticated.admin(shop);\n  return json(await getMyAppData({shop: session.shop));\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "admin",
          "examples": [
            {
              "description": "Use `admin.rest.get` to make custom requests to make a request to to the `customer/count` endpoint",
              "codeblock": {
                "title": "Performing a GET request to the REST API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n const { admin, session } = await unauthenticated.admin(request);\n\n const response = await admin.rest.get(\n   {\n     path: \"/customers/count.json\"\n   }\n );\n const customers = await response.json();\n\n return json({ customers });\n};",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\nimport { restResources } from \"@shopify/shopify-api/rest/admin/2023-04\";\n\nconst shopify = shopifyApp({\n restResources,\n // ...etc\n});\n\nexport default shopify;\nexport const unauthenticated = shopify.unauthenticated;",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Use `admin.graphql` to make query / mutation requests.",
              "codeblock": {
                "title": "Querying the GraphQL API",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n const { admin } = await unauthenticated.admin(request);\n\n const response = await admin.graphql(\n   `#graphql\n   mutation populateProduct($input: ProductInput!) {\n     productCreate(input: $input) {\n       product {\n         id\n       }\n     }\n    }`,\n    { variables: { input: { title: \"Product Name\" } } }\n  );\n\n const productData = await response.json();\n return json({ data: productData.data });\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n restResources,\n // ...etc\n});\nexport default shopify;\nexport const unauthenticated = shopify.unauthenticated;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "Unauthenticated storefront",
    "description": "Allows interacting with the Storefront API when working outside of Shopify requests.\nThis enables apps to integrate with 3rd party services and perform background tasks.\n\n> Caution:\n> This function doesn't perform **any** validation and shouldn't rely on raw user input.\n\nWhen using this function, consider the following:\n\n#### Background tasks\n\nApps should ensure that the shop domain is authenticated when enqueueing jobs.\n\n#### 3rd party service requests\n\nApps must obtain the shop domain from the 3rd party service in a secure way.",
    "category": "Unauthenticated",
    "type": "object",
    "isVisualComponent": false,
    "definitions": [
      {
        "title": "unauthenticated.storefront",
        "description": "Creates an unauthenticated Storefront context.",
        "type": "GetUnauthenticatedStorefrontContext",
        "typeDefinitions": {
          "GetUnauthenticatedStorefrontContext": {
            "filePath": "src/server/unauthenticated/storefront/types.ts",
            "name": "GetUnauthenticatedStorefrontContext",
            "description": "",
            "params": [
              {
                "name": "shop",
                "description": "",
                "value": "string",
                "filePath": "src/server/unauthenticated/storefront/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/unauthenticated/storefront/types.ts",
              "description": "",
              "name": "Promise<UnauthenticatedStorefrontContext>",
              "value": "Promise<UnauthenticatedStorefrontContext>"
            },
            "value": "export type GetUnauthenticatedStorefrontContext = (\n  shop: string,\n) => Promise<UnauthenticatedStorefrontContext>;"
          },
          "UnauthenticatedStorefrontContext": {
            "filePath": "src/server/unauthenticated/storefront/types.ts",
            "name": "UnauthenticatedStorefrontContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/unauthenticated/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "Session",
                "description": "The session for the given shop.\n\nThis comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n\nThis will always be an offline session. You can use this to get shop specific data.",
                "examples": [
                  {
                    "title": "Using the offline session",
                    "description": "Get your app's shop-specific data using the returned offline `session` object.",
                    "tabs": [
                      {
                        "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) => {\n  const shop = getShopFromExternalRequest(request);\n  const { session } = await unauthenticated.storefront(shop);\n  return json(await getMyAppData({shop: session.shop));\n};",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/server/unauthenticated/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "StorefrontContext",
                "description": "Method for interacting with the Shopify GraphQL Storefront API for the given store."
              }
            ],
            "value": "export interface UnauthenticatedStorefrontContext {\n  /**\n   * The session for the given shop.\n   *\n   * This comes from the session storage which `shopifyApp` uses to store sessions in your database of choice.\n   *\n   * This will always be an offline session. You can use this to get shop specific data.\n   *\n   * @example\n   * <caption>Using the offline session.</caption>\n   * <description>Get your app's shop-specific data using the returned offline `session` object.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { unauthenticated } from \"../shopify.server\";\n   * import { getMyAppData } from \"~/db/model.server\";\n   *\n   * export const loader = async ({ request }: LoaderFunctionArgs) => {\n   *   const shop = getShopFromExternalRequest(request);\n   *   const { session } = await unauthenticated.storefront(shop);\n   *   return json(await getMyAppData({shop: session.shop));\n   * };\n   * ```\n   */\n  session: Session;\n\n  /**\n   * Method for interacting with the Shopify GraphQL Storefront API for the given store.\n   */\n  storefront: StorefrontContext;\n}"
          },
          "Session": {
            "filePath": "../shopify-api/lib/session/session.ts",
            "name": "Session",
            "description": "Stores App information from logged in merchants so they can make authenticated requests to the Admin API.",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain, such as `example.myshopify.com`."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "scope",
                "value": "string",
                "description": "The desired scopes for the access token, at the time the session was created."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isActive",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isScopeChanged",
                "value": "(scopes: string | string[] | AuthScopes) => boolean",
                "description": "Whether the access token has the given scopes."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "isExpired",
                "value": "(withinMillisecondsOfExpiry?: number) => boolean",
                "description": "Whether the access token is expired."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toObject",
                "value": "() => SessionParams",
                "description": "Converts an object with data into a Session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(other: Session) => boolean",
                "description": "Checks whether the given session is equal to this session."
              },
              {
                "filePath": "../shopify-api/lib/session/session.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toPropertyArray",
                "value": "(returnUserData?: boolean) => [string, string | number | boolean][]",
                "description": "Converts the session into an array of key-value pairs."
              }
            ],
            "value": "export class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.\n   */\n  public isActive(scopes: AuthScopes | string | string[]): boolean {\n    return (\n      !this.isScopeChanged(scopes) &&\n      Boolean(this.accessToken) &&\n      !this.isExpired()\n    );\n  }\n\n  /**\n   * Whether the access token has the given scopes.\n   */\n  public isScopeChanged(scopes: AuthScopes | string | string[]): boolean {\n    const scopesObject =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n\n    return !scopesObject.equals(this.scope);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}"
          },
          "OnlineAccessInfo": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessInfo",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires_in",
                "value": "number",
                "description": "How long the access token is valid for, in seconds."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user_scope",
                "value": "string",
                "description": "The effective set of scopes for the session."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "associated_user",
                "value": "OnlineAccessUser",
                "description": "The user associated with the access token."
              }
            ],
            "value": "export interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}"
          },
          "OnlineAccessUser": {
            "filePath": "../shopify-api/lib/auth/oauth/types.ts",
            "name": "OnlineAccessUser",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "number",
                "description": "The user's ID."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "first_name",
                "value": "string",
                "description": "The user's first name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "last_name",
                "value": "string",
                "description": "The user's last name."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email",
                "value": "string",
                "description": "The user's email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "email_verified",
                "value": "boolean",
                "description": "Whether the user has verified their email address."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "account_owner",
                "value": "boolean",
                "description": "Whether the user is the account owner."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "string",
                "description": "The user's locale."
              },
              {
                "filePath": "../shopify-api/lib/auth/oauth/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collaborator",
                "value": "boolean",
                "description": "Whether the user is a collaborator."
              }
            ],
            "value": "export interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}"
          },
          "AuthScopes": {
            "filePath": "../shopify-api/lib/auth/scopes/index.ts",
            "name": "AuthScopes",
            "description": "A class that represents a set of access token scopes.",
            "members": [
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "has",
                "value": "(scope: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes includes the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "equals",
                "value": "(otherScopes: string | string[] | AuthScopes) => boolean",
                "description": "Checks whether the current set of scopes equals the given one."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a comma-separated string with the current set of scopes."
              },
              {
                "filePath": "../shopify-api/lib/auth/scopes/index.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toArray",
                "value": "() => any[]",
                "description": "Returns an array with the current set of scopes."
              }
            ],
            "value": "class AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray() {\n    return [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}"
          },
          "SessionParams": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "name": "SessionParams",
            "description": "",
            "members": [
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "name": "[key: string]",
                "value": "any"
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The unique identifier for the session."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "string",
                "description": "The Shopify shop domain."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "state",
                "value": "string",
                "description": "The state of the session. Used for the OAuth authentication code flow."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isOnline",
                "value": "boolean",
                "description": "Whether the access token in the session is online or offline."
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "scope",
                "value": "string",
                "description": "The scopes for the access token.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date",
                "description": "The date the access token expires.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "accessToken",
                "value": "string",
                "description": "The access token for the session.",
                "isOptional": true
              },
              {
                "filePath": "../shopify-api/lib/session/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "onlineAccessInfo",
                "value": "OnlineAccessInfo | StoredOnlineAccessInfo",
                "description": "Information on the user for the session. Only present for online sessions.",
                "isOptional": true
              }
            ],
            "value": "export interface SessionParams {\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain.\n   */\n  shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  isOnline: boolean;\n  /**\n   * The scopes for the access token.\n   */\n  scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  onlineAccessInfo?: OnlineAccessInfo | StoredOnlineAccessInfo;\n  /**\n   * Additional properties of the session allowing for extension\n   */\n  [key: string]: any;\n}"
          },
          "StoredOnlineAccessInfo": {
            "filePath": "../shopify-api/lib/session/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StoredOnlineAccessInfo",
            "value": "Omit<OnlineAccessInfo, 'associated_user'> & {\n  associated_user: Partial<OnlineAccessUser>;\n}",
            "description": ""
          },
          "StorefrontContext": {
            "filePath": "src/server/clients/storefront/types.ts",
            "name": "StorefrontContext",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/storefront/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "graphql",
                "value": "GraphQLClient<StorefrontOperations>",
                "description": "Method for interacting with the Shopify Storefront GraphQL API\n\nIf you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n\n\n\n\n",
                "examples": [
                  {
                    "title": "Querying the GraphQL API",
                    "description": "Use `storefront.graphql` to make query / mutation requests.",
                    "tabs": [
                      {
                        "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                        "title": "app/routes/**\\/.ts"
                      }
                    ]
                  },
                  {
                    "title": "Handling GraphQL errors",
                    "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
                    "tabs": [
                      {
                        "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) => {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  try {\n    const response = await storefront.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // { errors: { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] } }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                        "title": "/app/routes/**\\/*.ts"
                      },
                      {
                        "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                        "title": "/app/shopify.server.ts"
                      }
                    ]
                  }
                ]
              }
            ],
            "value": "export interface StorefrontContext {\n  /**\n   * Method for interacting with the Shopify Storefront GraphQL API\n   *\n   * If you're getting incorrect type hints in the Shopify template, follow [these instructions](https://github.com/Shopify/shopify-app-template-remix/tree/main#incorrect-graphql-hints).\n   *\n   * {@link https://shopify.dev/docs/api/storefront}\n   *\n   * @example\n   * <caption>Querying the GraphQL API.</caption>\n   * <description>Use `storefront.graphql` to make query / mutation requests.</description>\n   * ```ts\n   * // app/routes/**\\/.ts\n   * import { json } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Handling GraphQL errors.</caption>\n   * <description>Catch `GraphqlQueryError` errors to see error messages from the API.</description>\n   * ```ts\n   * // /app/routes/**\\/*.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { storefront } = await authenticate.public.appProxy(request);\n   *\n   *   try {\n   *     const response = await storefront.graphql(\n   *       `#graphql\n   *       query incorrectQuery {\n   *         products(first: 10) {\n   *           nodes {\n   *             not_a_field\n   *           }\n   *         }\n   *       }`,\n   *     );\n   *\n   *     return json({ data: await response.json() });\n   *   } catch (error) {\n   *     if (error instanceof GraphqlQueryError) {\n   *       // { errors: { graphQLErrors: [\n   *       //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n   *       // ] } }\n   *       return json({ errors: error.body?.errors }, { status: 500 });\n   *     }\n   *     return json({ message: \"An error occurred\" }, { status: 500 });\n   *   }\n   * }\n   * ```\n   *\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  graphql: GraphQLClient<StorefrontOperations>;\n}"
          },
          "GraphQLClient": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLClient",
            "description": "",
            "params": [
              {
                "name": "query",
                "description": "",
                "value": "Operation extends keyof Operations",
                "filePath": "src/server/clients/types.ts"
              },
              {
                "name": "options",
                "description": "",
                "value": "GraphQLQueryOptions<Operation, Operations>",
                "isOptional": true,
                "filePath": "src/server/clients/types.ts"
              }
            ],
            "returns": {
              "filePath": "src/server/clients/types.ts",
              "description": "",
              "name": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}",
              "value": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}, interface Promise<T> {}, Promise: PromiseConstructor, interface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}, interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n}"
            },
            "value": "export type GraphQLClient<Operations extends AllOperations> = <\n  Operation extends keyof Operations,\n>(\n  query: Operation,\n  options?: GraphQLQueryOptions<Operation, Operations>,\n) => Promise<GraphQLResponse<Operation, Operations>>;"
          },
          "GraphQLQueryOptions": {
            "filePath": "src/server/clients/types.ts",
            "name": "GraphQLQueryOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "ApiClientRequestOptions<Operation, Operations>[\"variables\"]",
                "description": "The variables to pass to the operation.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "apiVersion",
                "value": "ApiVersion",
                "description": "The version of the API to use for the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "Record<string, any>",
                "description": "Additional headers to include in the request.",
                "isOptional": true
              },
              {
                "filePath": "src/server/clients/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "tries",
                "value": "number",
                "description": "The total number of times to try the request if it fails.",
                "isOptional": true
              }
            ],
            "value": "export interface GraphQLQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to pass to the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * The version of the API to use for the request.\n   */\n  apiVersion?: ApiVersion;\n  /**\n   * Additional headers to include in the request.\n   */\n  headers?: Record<string, any>;\n  /**\n   * The total number of times to try the request if it fails.\n   */\n  tries?: number;\n}"
          },
          "ApiVersion": {
            "filePath": "../shopify-api/lib/types.ts",
            "syntaxKind": "EnumDeclaration",
            "name": "ApiVersion",
            "value": "export enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  Unstable = 'unstable',\n}",
            "members": [
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October22",
                "value": "2022-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January23",
                "value": "2023-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April23",
                "value": "2023-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "July23",
                "value": "2023-07"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "October23",
                "value": "2023-10"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "January24",
                "value": "2024-01"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "April24",
                "value": "2024-04"
              },
              {
                "filePath": "../shopify-api/lib/types.ts",
                "name": "Unstable",
                "value": "unstable"
              }
            ]
          }
        }
      }
    ],
    "jsDocTypeExamples": [
      "UnauthenticatedStorefrontContext",
      "StorefrontContext"
    ],
    "related": [
      {
        "name": "API context",
        "subtitle": "Interact with the Storefront API.",
        "url": "/docs/api/shopify-app-remix/apis/storefront-api"
      }
    ],
    "examples": {
      "description": "",
      "exampleGroups": [
        {
          "title": "session",
          "examples": [
            {
              "description": "Get your app's shop-specific data using the returned offline `session` object.",
              "codeblock": {
                "title": "Using the offline session",
                "tabs": [
                  {
                    "title": "app/routes/**\\/.ts",
                    "code": "import { LoaderFunctionArgs, json } from \"@remix-run/node\";\nimport { unauthenticated } from \"../shopify.server\";\nimport { getMyAppData } from \"~/db/model.server\";\n\nexport const loader = async ({ request }: LoaderFunctionArgs) =&gt; {\n  const shop = getShopFromExternalRequest(request);\n  const { session } = await unauthenticated.storefront(shop);\n  return json(await getMyAppData({shop: session.shop));\n};",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "graphql",
          "examples": [
            {
              "description": "Use `storefront.graphql` to make query / mutation requests.",
              "codeblock": {
                "title": "Querying the GraphQL API",
                "tabs": [
                  {
                    "title": "app/routes/**\\/.ts",
                    "code": "import { json } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  const response = await storefront.graphql(`{blogs(first: 10) { edges { node { id } } } }`);\n\n  return json(await response.json());\n}",
                    "language": "typescript"
                  }
                ]
              }
            },
            {
              "description": "Catch `GraphqlQueryError` errors to see error messages from the API.",
              "codeblock": {
                "title": "Handling GraphQL errors",
                "tabs": [
                  {
                    "title": "/app/routes/**\\/*.ts",
                    "code": "import { ActionFunctionArgs } from \"@remix-run/node\";\nimport { authenticate } from \"../shopify.server\";\n\nexport const action = async ({ request }: ActionFunctionArgs) =&gt; {\n  const { storefront } = await authenticate.public.appProxy(request);\n\n  try {\n    const response = await storefront.graphql(\n      `#graphql\n      query incorrectQuery {\n        products(first: 10) {\n          nodes {\n            not_a_field\n          }\n        }\n      }`,\n    );\n\n    return json({ data: await response.json() });\n  } catch (error) {\n    if (error instanceof GraphqlQueryError) {\n      // { errors: { graphQLErrors: [\n      //   { message: \"Field 'not_a_field' doesn't exist on type 'Product'\" }\n      // ] } }\n      return json({ errors: error.body?.errors }, { status: 500 });\n    }\n    return json({ message: \"An error occurred\" }, { status: 500 });\n  }\n}",
                    "language": "typescript"
                  },
                  {
                    "title": "/app/shopify.server.ts",
                    "code": "import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n\nconst shopify = shopifyApp({\n  // ...\n});\nexport default shopify;\nexport const authenticate = shopify.authenticate;",
                    "language": "typescript"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  }
]